<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
 lang="en" dir="ltr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>
    libssh:documentation    [0xbadc0de.be]
  </title>

  <meta name="generator" content="DokuWiki Release 2006-11-06" />
<meta name="robots" content="index,follow" />
<meta name="date" content="2006-11-07T17:46:01+0100" />
<meta name="keywords" content="libssh,documentation" />
<link rel="start" href="/wiki/" />
<link rel="contents" href="/wiki/libssh:documentation?do=index" title="Index" />
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="/wiki/feed.php" />
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="/wiki/feed.php?mode=list&amp;ns=libssh" />
<link rel="alternate" type="text/html" title="Plain HTML" href="/wiki/_export/xhtml/libssh:documentation" />
<link rel="alternate" type="text/plain" title="Wiki Markup" href="/wiki/_export/raw/libssh:documentation" />
<link rel="stylesheet" media="screen" type="text/css" href="/wiki/lib/exe/css.php" />
<link rel="stylesheet" media="print" type="text/css" href="/wiki/lib/exe/css.php?print=1" />
<script type="text/javascript" charset="utf-8" src="/wiki/lib/exe/js.php?edit=0&amp;write=0" ></script>

  <link rel="shortcut icon" href="/wiki/lib/tpl/default/images/favicon.ico" />

  </head>

<body>
<div class="dokuwiki">
  
  <div class="stylehead">

    <div class="header">
      <div class="pagename">
        [[<a href="/wiki/libssh:documentation?do=backlink" >libssh:documentation</a>]]
      </div>
      <div class="logo">
        <a href="/wiki/"  name="dokuwiki__top" id="dokuwiki__top" accesskey="h" title="[ALT+H]">0xbadc0de.be</a>      </div>

      <div class="clearer"></div>
    </div>

    
    <div class="bar" id="bar__top">
      <div class="bar-left" id="bar__topleft">
        <form class="button" method="post" action="/wiki/libssh:documentation"><div class="no"><input type="hidden" name="do" value="edit" /><input type="hidden" name="rev" value="" /><input type="submit" value="Show pagesource" class="button" accesskey="v" title="Show pagesource [ALT+V]" /></div></form>        <form class="button" method="get" action="/wiki/libssh:documentation"><div class="no"><input type="hidden" name="do" value="revisions" /><input type="submit" value="Old revisions" class="button" accesskey="o" title="Old revisions [ALT+O]" /></div></form>      </div>

      <div class="bar-right" id="bar__topright">
        <form class="button" method="get" action="/wiki/"><div class="no"><input type="hidden" name="do" value="recent" /><input type="submit" value="Recent changes" class="button" accesskey="r" title="Recent changes [ALT+R]" /></div></form>        <form action="/wiki/" accept-charset="utf-8" class="search" id="dw__search"><div class="no"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch__in" accesskey="f" name="id" class="edit" title="[ALT+F]" /><input type="submit" value="Search" class="button" title="Search" /><div id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>&nbsp;
      </div>

      <div class="clearer"></div>
    </div>

        <div class="breadcrumbs">
      Trace: <span class="bcsep">&raquo;</span> <a href="/wiki/libssh:libssh"  class="breadcrumbs" title="libssh:libssh">libssh</a> <span class="bcsep">&raquo;</span> <span class="curid"><a href="/wiki/libssh:documentation"  class="breadcrumbs" title="libssh:documentation">documentation</a></span>          </div>
    
    
  </div>
  
  
  <div class="page">
    <!-- wikipage start -->
    <div class="toc">
<div class="tocheader toctoggle" id="toc__header">Table of Contents</div>
<div id="toc__inside">

<ul class="toc">
<li class="level1"><div class="li"><span class="li"><a href="#libssh_0.11_api_guide" class="toc">LIBSSH 0.11 API GUIDE</a></span></div>
<ul class="toc">
<li class="level2"><div class="li"><span class="li"><a href="#introduction" class="toc">0 Introduction</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#setting_the_options" class="toc">1- Setting the options</a></span></div>
<ul class="toc">
<li class="level3"><div class="li"><span class="li"><a href="#a_the_easy_way" class="toc">a the easy way</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#b_the_long_way" class="toc">b the long way</a></span></div></li>
</ul>
</li>
<li class="level2"><div class="li"><span class="li"><a href="#connecting_the_ssh_server" class="toc">2- Connecting the ssh server</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#authenticating_to_server" class="toc">3- Authenticating to server</a></span></div>
<ul class="toc">
<li class="level3"><div class="li"><span class="li"><a href="#public_keys" class="toc">Public keys</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#password" class="toc">Password</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#keyboard-interactive" class="toc">Keyboard-interactive</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#none" class="toc">&quot;none&quot;</a></span></div></li>
</ul>
</li>
<li class="level2"><div class="li"><span class="li"><a href="#opening_a_channel" class="toc">4- Opening a channel</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#the_shell" class="toc">5- The shell</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#the_sftp_subsystem" class="toc">6- The SFTP subsystem</a></span></div>
<ul class="toc">
<li class="level3"><div class="li"><span class="li"><a href="#a_opening_the_session" class="toc">A) Opening the session</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#b_opening_and_reading_a_directory" class="toc">B) Opening and reading a directory</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#c_opening_reading_writing_files" class="toc">C) Opening, reading, writing files</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#d_closing_the_session" class="toc">D) Closing the session</a></span></div></li>
</ul>
</li>
<li class="level2"><div class="li"><span class="li"><a href="#final_word" class="toc">8- Final word</a></span></div></li></ul>
</li></ul>
</div>
</div>



<h1><a name="libssh_0.11_api_guide" id="libssh_0.11_api_guide">LIBSSH 0.11 API GUIDE</a></h1>
<div class="level1">

<p>
 ... Or everything you ever wanted to know about a simple and fast ssh library.
</p>

</div>

<h2><a name="introduction" id="introduction">0 Introduction</a></h2>
<div class="level2">

<p>
 Before inserting ssh hooks into your programs, you must know some basics about the ssh protocol, and understand why the ssh library must implement them. Lot of the protocols specifications are hidden by the ssh library <acronym title="Application Programming Interface">API</acronym> (of course !) but some still needs an attention from the end-user programmer. Note that libssh is still an alpha product, and the <acronym title="Application Programming Interface">API</acronym> may vary from one version to another. The only guess I can make is that the <acronym title="Application Programming Interface">API</acronym> won&rsquo;t radically change.
</p>

<p>
The <acronym title="Secure Shell">SSH</acronym> protocol was designed for some goals which I resume here :
</p>
<ul>
<li class="level1"><div class="li"> Privacy of data</div>
</li>
<li class="level1"><div class="li"> Security</div>
</li>
<li class="level1"><div class="li"> Authentication of the server</div>
</li>
<li class="level1"><div class="li"> Authentication of the client.</div>
</li>
</ul>

<p>
The client MUST be sure who&rsquo;s speaking to before entering into any authentication way. That&rsquo;s where the end programmer must ensure the given fingerprints *are* from the legitimate server. A ssh connection must follow the following steps:
</p>
<ol>
<li class="level1"><div class="li"> Before connecting the socket, you can set up if you wish one or other server public key authentication ie. DSA or RSA. You can choose cryptographic algorithms you trust and compression algorithms if any.</div>
</li>
<li class="level1"><div class="li"> The connection is made. A secure handshake is made, and resulting from it, a public key from the server is gained. You MUST verify that the public key is legitimate.</div>
</li>
<li class="level1"><div class="li"> The client must authenticate : the two implemented ways are password, and public keys (from dsa and rsa key-pairs generated by openssh). It is harmless to authenticate to a fake server with these keys because the protocol ensures the data you sign can&rsquo;t be used twice. It just avoids man-in-the-middle attacks.</div>
</li>
<li class="level1"><div class="li"> Now that the user has been authenticated, you must open one or several channels. channels are different subways for information into a single ssh connection. Each channel has a standard stream (stdout) and an error stream (stderr). You can theoretically open an infinity of channel.</div>
</li>
<li class="level1"><div class="li"> With the channel you opened, you can do several things :</div>
<ul>
<li class="level2"><div class="li"> Open a shell. You may want to request a pseudo virtual terminal before</div>
</li>
<li class="level2"><div class="li"> Execute a command. The virtual terminal is usable, too</div>
</li>
<li class="level2"><div class="li"> Invoke the sftp subsystem. (look at chapter 6)</div>
</li>
<li class="level2"><div class="li"> invoke your own subsystem. This is out the scope of this document but it is easy to do.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> When everything is finished, just close the channels, and then the connection.</div>
</li>
</ol>

<p>
 At every place, a function which returns an error code (typically -1 for int values, NULL for pointers) also sets an error message and an error code. I high-lined the main steps, now that&rsquo;s you to follow them :)
</p>

</div>

<h2><a name="setting_the_options" id="setting_the_options">1- Setting the options</a></h2>
<div class="level2">

<p>
 The options mechanism will change during updates of the library, but the functions which exists now will certainly be kept.
</p>

<p>
The ssh system needs to know the preferences of the user, the trust into one or another algorithm and such. More important informations have to be given before connecting : the host name of the server, the port (if non default), the binding address, the default username, ... The options structure is given to a ssh_connect function, then this option structure is used again and again by the ssh implementation. you shall not free it manually, and you shall not share it with multiple sessions. Two ways are given for setting the options : the easy one (of course !) and the long-but-accurate one.
</p>

</div>

<h3><a name="a_the_easy_way" id="a_the_easy_way">a the easy way</a></h3>
<div class="level3">

<p>
Lot of ssh options in fact come from the command line of the program... you could parse them and then use the long way for every argument, but libssh has a mechanism to do that for you, automatically.
</p>

</div>

<h5><a name="ssh_options_ssh_getopt_int_argcptr_char_argv" id="ssh_options_ssh_getopt_int_argcptr_char_argv">SSH_OPTIONS *ssh_getopt(int *argcptr, char **argv);</a></h5>
<div class="level5">

<p>
 this function will return you a new options pointer based on the arguments you give in parameters. better, they clean the argv array from used parameters so you can use them after in your own program
</p>
<pre class="code">int main(int argc, char *argv[]){
  SSH_OPTIONS *opt;
  opt=ssh_getopt(&amp;argc, argv);
  if(!opt){
      ...
  }</pre>

<p>
the function will return NULL if some problem is appearing.<br/>
 As a matter of portability for you own programs, the hostname isn&rsquo;t always the first argument from the command line, so the single arguments (not preceded by a -something) won&rsquo;t be parsed.<br/>
 example:<br/>

</p>
<pre class="code">user@host:~$ myssh -u aris localhost</pre>

<p>
-u aris will be caught, localhost wont.<br/>
 cfr the options_set_user() function in the next part for more informations about it.<br/>

</p>

</div>

<h3><a name="b_the_long_way" id="b_the_long_way">b the long way</a></h3>
<div class="level3">

</div>

<h5><a name="ssh_options_options_new" id="ssh_options_options_new">SSH_OPTIONS *options_new();</a></h5>
<div class="level5">

<p>
 This function returns an empty but initialized option structure pointer.<br/>
 The structure is freed by ssh_disconnect described later, so don&rsquo;t use the existing function options_free() (it&rsquo;s an internal function).<br/>
 So : use it only for one ssh_connect(), never free it.<br/>

</p>

</div>

<h5><a name="ssh_options_options_copy_ssh_options_opt" id="ssh_options_options_copy_ssh_options_opt">SSH_OPTIONS *options_copy(SSH_OPTIONS *opt);</a></h5>
<div class="level5">

<p>
If you need to duplicate an option object before using it, use this function.<br/>

</p>

<p>
The following functions are all of the following form :<br/>

</p>
<pre class="code">int options_set_something(SSH_OPTIONS *opt, something);</pre>

<p>
the something parameters are always internaly copied, so you don&rsquo;t have to strdup them.<br/>
 some return eather 0 or -1, in which case an error message appears in the error functions, others never fail (return void).<br/>
 The error codes and descriptions for these functions are recoverable throught 
</p>
<pre class="code">ssh_get_error(NULL);</pre>

</div>

<h5><a name="int_options_set_wanted_method_ssh_options_opt_int_method_char_list" id="int_options_set_wanted_method_ssh_options_opt_int_method_char_list">int options_set_wanted_method(SSH_OPTIONS *opt,int method, char *list);</a></h5>
<div class="level5">

<p>
 Passing an option structure, a ssh macro for the method, and a list of allowed parameters indicates libssh you want to use these.<br/>
 The macros are :<br/>

</p>
<ul>
<li class="level1"><div class="li"> KEX_ALGO</div>
</li>
<li class="level1"><div class="li"> KEX_HOSTKEY Server public key type expected</div>
</li>
<li class="level1"><div class="li"> KEX_CRYPT_C_S Cryptographic algorithm client&rarr;server</div>
</li>
<li class="level1"><div class="li"> KEX_CRYPT_S_C Cryptographic algorithm server&rarr;client</div>
</li>
<li class="level1"><div class="li"> KEX_MAC_C_S Unused</div>
</li>
<li class="level1"><div class="li"> KEX_MAC_S_C Unused</div>
</li>
<li class="level1"><div class="li"> KEX_COMP_C_S Compression method for the stream (&rdquo;zlib&rdquo; or &ldquo;none&rdquo;), client to server</div>
</li>
<li class="level1"><div class="li"> KEX_COMP_S_C Compression method for the stream (&rdquo;zlib&rdquo; or &ldquo;none&rdquo;), server to client</div>
</li>
<li class="level1"><div class="li"> KEX_LANG_C_S Do not use</div>
</li>
<li class="level1"><div class="li"> KEX_LANG_S_C Do not use</div>
</li>
</ul>

<p>
 Currently, only KEX_HOSTKEY and ,KEX_CRYPT_C_S,S_C, KEX_COMP_C_S and S_C work as expected. the list is a comma separated string of prefered algorithms/methods, in order of preference.<br/>

</p>

<p>
example : this sets the ssh stream to be compressed in client&rarr;server mode only<br/>

</p>
<pre class="code">ret = option_set_wanted_method(options,KEX_COMP_C_S,&quot;zlib&quot;);</pre>

<p>
example: this will set the cryptographic algorithms wanted from server to client to aes128-cbc and then aes192-cbc if the first one isn&rsquo;t supported by server:<br/>

</p>
<pre class="code">ret = option_set_wanted_method(options,KEX_CRYPT_S_C,&quot;aes128-cbc,aes192-cbc&quot;);</pre>

<p>
if you prefer getting the Dss key from a server instead of rsa, but you still accept rsa if dss isn&rsquo;t available :<br/>

</p>
<pre class="code">options_set_wanted_method(options,KEX_HOSTKEY,&quot;ssh-dss,ssh-rsa&quot;);</pre>

<p>
return value:<br/>
 0 if the option is valid, -1 else.<br/>
 An error is set in that case.<br/>

</p>

</div>

<h5><a name="void_options_set_port_ssh_options_opt_unsigned_int_port" id="void_options_set_port_ssh_options_opt_unsigned_int_port">void options_set_port(SSH_OPTIONS *opt, unsigned int port);</a></h5>
<div class="level5">

<p>
this function sets the server port.<br/>

</p>

</div>

<h5><a name="void_options_set_host_ssh_options_opt_const_char_hostname" id="void_options_set_host_ssh_options_opt_const_char_hostname">void options_set_host(SSH_OPTIONS *opt, const char *hostname);</a></h5>
<div class="level5">

<p>
this function sets the hostname of the server. It also supports &ldquo;user@hostname&rdquo; syntax in which case the user options is set too.<br/>

</p>

</div>

<h5><a name="void_options_set_fd_ssh_options_opt_int_fd" id="void_options_set_fd_ssh_options_opt_int_fd">void options_set_fd(SSH_OPTIONS *opt, int fd);</a></h5>
<div class="level5">

<p>
permits you to specify an opened file descriptor you&rsquo;ve opened yourself.<br/>
 It&rsquo;s a good way of bypassing the internal FD opening in libssh, but there are things you should take care of :<br/>

</p>
<ol>
<li class="level1"><div class="li"> The file descriptor should be returned to libssh without nonblocking settings</div>
</li>
<li class="level1"><div class="li"> If you wish to use is_server_known() You should also set options_set_host... Otherwise libssh won&rsquo;t have any way of certifying the server is known or not.</div>
</li>
</ol>

</div>

<h5><a name="void_options_set_bindaddr_ssh_options_opt_char_bindaddr" id="void_options_set_bindaddr_ssh_options_opt_char_bindaddr">void options_set_bindaddr(SSH_OPTIONS *opt, char *bindaddr);</a></h5>
<div class="level5">

<p>
this function allows you to set the binding address, in case your computer has multiple IP or interfaces. it supports both hostnames and IP&rsquo;s<br/>

</p>

</div>

<h5><a name="void_options_set_username_ssh_options_opt_char_username" id="void_options_set_username_ssh_options_opt_char_username">void options_set_username(SSH_OPTIONS *opt,char *username);</a></h5>
<div class="level5">

<p>
sets username for authenticating in this session.<br/>

</p>

</div>

<h5><a name="void_option_set_timeout_ssh_options_opt_long_seconds_long_usec" id="void_option_set_timeout_ssh_options_opt_long_seconds_long_usec">void option_set_timeout(SSH_OPTIONS *opt,long seconds, long usec);</a></h5>
<div class="level5">

<p>
sets the timeout for connecting to the socket. It does not include a timeout for the name resolving or handshake.
</p>

</div>

<h5><a name="void_options_set_ssh_dir_ssh_options_opt_char_dir" id="void_options_set_ssh_dir_ssh_options_opt_char_dir">void options_set_ssh_dir(SSH_OPTIONS *opt, char *dir);</a></h5>
<div class="level5">

<p>
this function sets the .ssh/ directory used by libssh. You may use a %s which will be replaced by the home directory of the user. NEVER accept parameters others than the user&rsquo;s one, they may contain format strings which are a security hole if a malicious agent gives it.<br/>

</p>

</div>

<h5><a name="void_options_set_known_hosts_file_ssh_options_opt_char_dir" id="void_options_set_known_hosts_file_ssh_options_opt_char_dir">void options_set_known_hosts_file(SSH_OPTIONS *opt, char *dir);</a></h5>
<div class="level5">

<p>
same than options_set_ssh_dir() for known_hosts file.
</p>

</div>

<h5><a name="void_options_set_identity_ssh_options_opt_char_identity" id="void_options_set_identity_ssh_options_opt_char_identity">void options_set_identity(SSH_OPTIONS *opt, char *identity);</a></h5>
<div class="level5">

<p>
same than upper for the identity file (they come by pair, the one asked is the file without the .pub suffix)
</p>

</div>

<h5><a name="void_options_set_status_callback_ssh_options_opt_void_callback_void_arg_float_status_void_arg" id="void_options_set_status_callback_ssh_options_opt_void_callback_void_arg_float_status_void_arg">void options_set_status_callback(SSH_OPTIONS *opt, void (*callback)(void *arg, float status), void *arg);</a></h5>
<div class="level5">

<p>
Because more and more developpers use libssh with <acronym title="Graphical User Interface">GUI</acronym>, I&rsquo;ve added this function to make the ssh_connect function more interactive. This permits to set a callback of the form
</p>
<pre class="code">void function(void *userarg, float status);</pre>

<p>
with status going from 0 to 1 during ssh_connect. The callback won&rsquo;t ever be called after the connection is made.
</p>

</div>

<h2><a name="connecting_the_ssh_server" id="connecting_the_ssh_server">2- Connecting the ssh server</a></h2>
<div class="level2">

<p>
 The <acronym title="Application Programming Interface">API</acronym> provides an abstract data type, <code><acronym title="Secure Shell">SSH</acronym>_SESSION</code>, which describes the connection to one particular server.<br/>
 You can make several connections to different servers under the same process because of this structure.
</p>

</div>

<h5><a name="ssh_session_ssh_connect_ssh_options_options" id="ssh_session_ssh_connect_ssh_options_options">SSH_SESSION *ssh_connect(SSH_OPTIONS *options);</a></h5>
<div class="level5">

<p>
This function returns a handle on the newly connection. This function expects to have a pre-set options structure.<br/>
 It returns NULL in case of error, in which case you can look at error messages for more informations.
</p>

</div>

<h5><a name="void_ssh_disconnect_ssh_session_session" id="void_ssh_disconnect_ssh_session_session">void ssh_disconnect(SSH_SESSION *session);</a></h5>
<div class="level5">

<p>
This function sends a polite disconnect message, and does clean the session.<br/>
 This is the proper way of finishing a ssh connection.
</p>

</div>

<h5><a name="int_ssh_get_pubkey_hash_ssh_session_session_char_hash_md5_digest_len" id="int_ssh_get_pubkey_hash_ssh_session_session_char_hash_md5_digest_len">int ssh_get_pubkey_hash(SSH_SESSION *session, char hash[MD5_DIGEST_LEN]);</a></h5>
<div class="level5">

<p>
This function places the MD5 hash of the server public key into the hash array.<br/>
 It&rsquo;s IMPORTANT to verify it matches the previous known value. One server always have the same hash. No other server/attacker can emulate it (or it&rsquo;d be caught by the public key verification procedure automatically made by libssh).<br/>
 You can skip this step if you correctly handle <code>is_server_known()</code><br/>

</p>

</div>

<h5><a name="int_ssh_is_server_known_ssh_session_session" id="int_ssh_is_server_known_ssh_session_session">int ssh_is_server_known(SSH_SESSION *session);</a></h5>
<div class="level5">

<p>
Checks the user&rsquo;s known host file to look for a previous connection to the specified server. Return values:<br/>

</p>
<ul>
<li class="level1"><div class="li"> <acronym title="Secure Shell">SSH</acronym>_SERVER_KNOWN_OK : the host is known and the key has not changed</div>
</li>
<li class="level1"><div class="li"> <acronym title="Secure Shell">SSH</acronym>_SERVER_KNOWN_CHANGED : The host&rsquo;s key has changed. Either you are under an active attack or the key changed. The <acronym title="Application Programming Interface">API</acronym> doesn&rsquo;t give any way to modify the key in known hosts yet. I Urge end developers to WARN the user about the possibility of an attack.</div>
</li>
<li class="level1"><div class="li"> <acronym title="Secure Shell">SSH</acronym>_SERVER_FOUND_OTHER: The host gave us a public key of one type, which does not exist yet in our known host file, but there is an other type of key which is know.</div>
</li>
</ul>

<p>
ie. server sent a DSA key and we had a RSA key. Be carreful it&rsquo;s a possible attack (coder should use option_set_wanted_method() to specify which key to use).
</p>
<ul>
<li class="level1"><div class="li"> <acronym title="Secure Shell">SSH</acronym>_SERVER_NOT_KNOWN: the server is unknown in known hosts. Possible reasons : case not matching, alias, ... In any case the user MUST confirm the Md5 hash is correct.</div>
</li>
<li class="level1"><div class="li"> <acronym title="Secure Shell">SSH</acronym>_SERVER_ERROR : Some error happened while opening known host file.</div>
</li>
</ul>

</div>

<h5><a name="int_ssh_write_knownhost_ssh_session_session" id="int_ssh_write_knownhost_ssh_session_session">int ssh_write_knownhost(SSH_SESSION *session);</a></h5>
<div class="level5">

<p>
write the current connected host as known in the known host file. returns a negative value if something went wrong. <br/>
 You generaly use it when ssh_is_server_known returned <acronym title="Secure Shell">SSH</acronym>_SERVER_NOT_KNOWN.
</p>

</div>

<h5><a name="int_pubkey_get_hash_ssh_session_session_char_hash_md5_digest_len" id="int_pubkey_get_hash_ssh_session_session_char_hash_md5_digest_len">int pubkey_get_hash(SSH_SESSION *session,char hash[MD5_DIGEST_LEN]);</a></h5>
<div class="level5">

<p>
deprecated but left for binary compatibility (will be removed in newer versions).<br/>

</p>

</div>

<h2><a name="authenticating_to_server" id="authenticating_to_server">3- Authenticating to server</a></h2>
<div class="level2">

<p>
 The ssh library supports the two most used authentication methods from <acronym title="Secure Shell">SSH</acronym>. In every function, there is a &ldquo;username&rdquo; argument. <br/>
 If NULL is given instead, the server will use the default username (which is guessed from what you gave to options_set_user or options_set_hostname or even the local user running the code). from libssh 0.11, you should always set the username during the OPTIONS and pass NULL arguments to the authentication functions.<br/>
 <br/>
 Authentication methods : 
</p>

</div>

<h3><a name="public_keys" id="public_keys">Public keys</a></h3>
<div class="level3">

<p>
 The public key is the only method which does not compromise your key if the remote host has been compromised (the server can&rsquo;t do anything more than getting your public key). This is <code>not</code> the case of a password authentication (the server can get your plaintext password).<br/>

</p>

<p>
Libssh is obviously fully compatible with the openssh public and private keys.<br/>
 The things go this way : you scan a list of files which contain public keys.<br/>
 For each key, you send it to ssh server until the server acknowledges a key (a key it knows). Then, you get the private key for this key and send a message proving you own that private key.<br/>
 Here again, two ways for the public key authentication... the easy and the complicated one.<br/>

</p>

</div>

<h4><a name="easy_way" id="easy_way">easy way</a></h4>
<div class="level4">

</div>

<h5><a name="int_ssh_userauth_autopubkey_ssh_session_session" id="int_ssh_userauth_autopubkey_ssh_session_session">int ssh_userauth_autopubkey(SSH_SESSION *session);</a></h5>
<div class="level5">

<p>
This function will try the most common places for finding the public and private keys (your home directory) or eventualy the identity files asked by the options_set_identity() function.<br/>
 The return values are :<br/>

</p>
<ul>
<li class="level1"><div class="li"> <acronym title="Secure Shell">SSH</acronym>_AUTH_ERROR : some serious error happened during authentication</div>
</li>
<li class="level1"><div class="li"> <acronym title="Secure Shell">SSH</acronym>_AUTH_DENIED : no key matched</div>
</li>
<li class="level1"><div class="li"> <acronym title="Secure Shell">SSH</acronym>_AUTH_SUCCESS : you are now authenticated</div>
</li>
<li class="level1"><div class="li"> <acronym title="Secure Shell">SSH</acronym>_AUTH_PARTIAL : some key matched but you still have to give an other mean of authentication (like password).</div>
</li>
</ul>

</div>

<h4><a name="peanful_way" id="peanful_way">peanful way</a></h4>
<div class="level4">

<p>
 there are three steps : you get a public key, you ask the server if the key matches a known one, if true, you get the private key and authenticate with it.<br/>

</p>

</div>

<h5><a name="string_publickey_from_file_char_filename_int_type" id="string_publickey_from_file_char_filename_int_type">STRING *publickey_from_file(char *filename,int *_type);</a></h5>
<div class="level5">

<p>
will return an handle on a public key. if you give a pointer to an int, a symbolic value will be placed there. Do it because you need it in next step.<br/>

</p>

</div>

<h5><a name="int_ssh_userauth_offer_pubkey_ssh_session_session_char_username_int_type_string_publickey" id="int_ssh_userauth_offer_pubkey_ssh_session_session_char_username_int_type_string_publickey">int ssh_userauth_offer_pubkey(SSH_SESSION *session, char *username, int type, STRING *publickey);</a></h5>
<div class="level5">

<p>
 this function will offer a public key to the server. <acronym title="Secure Shell">SSH</acronym>_AUTH_SUCCESS is returned if the key is accepted (in which case you&rsquo;ll want to get the private key), <acronym title="Secure Shell">SSH</acronym>_AUTH_DENIED otherwise.<br/>
 Still watch for <acronym title="Secure Shell">SSH</acronym>_AUTH_ERROR as connection problems might happen.<br/>

</p>

<p>
in case of <acronym title="Secure Shell">SSH</acronym>_AUTH_SUCCESS,
</p>

</div>

<h5><a name="private_key_privatekey_from_file_ssh_session_session_char_filename_int_type_char_passphrase" id="private_key_privatekey_from_file_ssh_session_session_char_filename_int_type_char_passphrase">PRIVATE_KEY *privatekey_from_file(SSH_SESSION *session,char *filename, int type,char *passphrase);</a></h5>
<div class="level5">

<p>
 will get the privatekey from the filename previously set by publickey_from_next_file(). You can call it with a passphrase for unlocking the key. If passphrase==NULL, the default prompt will be used.<br/>
 The function returns NULL if the private key wasn&rsquo;t opened (ie bad passphrase or missing file).
</p>

</div>

<h5><a name="int_ssh_userauth_pubkey_ssh_session_session_char_username_string_publickey_private_key_privatekey" id="int_ssh_userauth_pubkey_ssh_session_session_char_username_string_publickey_private_key_privatekey">int ssh_userauth_pubkey(SSH_SESSION *session, char *username, STRING *publickey, PRIVATE_KEY *privatekey);</a></h5>
<div class="level5">

<p>
 Will try to authenticate using the public and private key. It shall return <acronym title="Secure Shell">SSH</acronym>_AUTH_SUCCESS if you are authenticated, <acronym title="Secure Shell">SSH</acronym>_AUTH_ERROR, <acronym title="Secure Shell">SSH</acronym>_AUTH_DENIED or <acronym title="Secure Shell">SSH</acronym>_AUTH_PARTIAL depending of return condition.<br/>
 each public key (of type STRING) must be freed with the libc &ldquo;free&rdquo; function.<br/>
 The private key must be freed with private_key_free(PRIVATE_KEY *) which will clean the memory before (don&rsquo;t worry about passphrase leaking).<br/>

</p>

</div>

<h3><a name="password" id="password">Password</a></h3>
<div class="level3">

</div>

<h5><a name="int_ssh_userauth_password_ssh_session_session_char_username_char_password" id="int_ssh_userauth_password_ssh_session_session_char_username_char_password">int ssh_userauth_password(SSH_SESSION *session,char *username,char *password);</a></h5>
<div class="level5">

<p>
 Will return <acronym title="Secure Shell">SSH</acronym>_AUTH_SUCCESS if the password matched, one of other constants otherwise. It&rsquo;s your work to ask the password and to free it in a secure manner.<br/>
 If your server complains that the password is wrong, but you <strong>can</strong> authenticate using openssh&rsquo;s client, it&rsquo;s because openssh use Keyboard-interactive. Switch to keyboard-interactive authentication or try to configure Plaintext-passwords into the <acronym title="Secure Shell">SSH</acronym> server.
</p>

</div>

<h3><a name="keyboard-interactive" id="keyboard-interactive">Keyboard-interactive</a></h3>
<div class="level3">

</div>

<h5><a name="int_ssh_userauth_kbdint_ssh_session_session_char_user_char_submethods" id="int_ssh_userauth_kbdint_ssh_session_session_char_user_char_submethods">int ssh_userauth_kbdint(SSH_SESSION *session, char *user, char *submethods);</a></h5>
<div class="level5">

<p>
 This is the main keyboard-interactive function. It will return <acronym title="Secure Shell">SSH</acronym>_AUTH_SUCCESS,<acronym title="Secure Shell">SSH</acronym>_AUTH_DENIED, <acronym title="Secure Shell">SSH</acronym>_AUTH_PARTIAL, <acronym title="Secure Shell">SSH</acronym>_AUTH_ERROR depending on the result of the request.<br/>

</p>

<p>
The keyboard-interactive authentication method of SSH2 is a feature which permits the server to ask a certain number of questions in an interactive manner to the client, until it decides to accept or deny the login.<br/>

</p>

<p>
To begin, you call this function (you can omit user if it was set previously and omit submethods - instead you know what you do - just put them to NULL) and store the answer. If the answer is <acronym title="Secure Shell">SSH</acronym>_AUTH_INFO, it means the server has sent a few questions to ask your user, which you can retrieve with the following functions. Then, set the answers and call back ssh_userauth_kbdint with same arguments. It may again ask a few other questions etc. until you get an other <acronym title="Secure Shell">SSH</acronym>_AUTH code than <acronym title="Secure Shell">SSH</acronym>_AUTH_INFO.<br/>

</p>

<p>
Few remarks :<br/>

</p>
<ul>
<li class="level1"><div class="li"> Even the first call can return <acronym title="Secure Shell">SSH</acronym>_AUTH_DENIED or <acronym title="Secure Shell">SSH</acronym>_AUTH_SUCCESS.</div>
</li>
<li class="level1"><div class="li"> The server can send an empty question set (this is the default behavior on my system) after you have sent the answers to the first questions. you must still parse the answer, it might contain some message from the server saying hello or such things. Just call <code>ssh_userauth_kbdint()</code> once more.</div>
</li>
</ul>

</div>

<h5><a name="int_ssh_userauth_kbdint_getnprompts_ssh_session_session" id="int_ssh_userauth_kbdint_getnprompts_ssh_session_session">int ssh_userauth_kbdint_getnprompts(SSH_SESSION *session);</a></h5>
<div class="level5">

<p>
 After you called ssh_userauth_kbdint and got <acronym title="Secure Shell">SSH</acronym>_AUTH_INFO, the session contains a few questions (or prompts) from the server. This function returns the number of prompts and answers.<br/>
 It could be zero, in which case you must act as said previously.
</p>

</div>

<h5><a name="char_ssh_userauth_kbdint_getname_ssh_session_session" id="char_ssh_userauth_kbdint_getname_ssh_session_session">char *ssh_userauth_kbdint_getname(SSH_SESSION *session);</a></h5>
<div class="level5">

<p>
 This functions returns the &ldquo;name&rdquo; of the message block. The meaning is explained later.<br/>
 This function returns a pointer that stays valid until the next ssh_userauth_kbdint() call and must <strong>not</strong> be freed.
</p>

</div>

<h5><a name="char_ssh_userauth_kbdint_getinstruction_ssh_session_session" id="char_ssh_userauth_kbdint_getinstruction_ssh_session_session">char *ssh_userauth_kbdint_getinstruction(SSH_SESSION *session);</a></h5>
<div class="level5">

<p>
 This functions returns the &ldquo;instruction&rdquo; of the message block. The meaning is explained later.<br/>
 This function returns a pointer that stays valid until the next ssh_userauth_kbdint() call and must not be freed.
</p>

</div>

<h5><a name="char_ssh_userauth_kbdint_getprompt_ssh_session_session_int_i_char_echo" id="char_ssh_userauth_kbdint_getprompt_ssh_session_session_int_i_char_echo">char *ssh_userauth_kbdint_getprompt(SSH_SESSION *session,int i, char *echo);</a></h5>
<div class="level5">

<p>
 This functions returns a pointer to the nth prompt. The character pointed by echo, if different from null, will contain a boolean value after the call, which means that the user prompt must be echoed or not.<br/>
 zero means that the echo is Off (like for a password prompt).<br/>
 any other value means the echo is on.<br/>
 This function returns a pointer that stays valid until the next ssh_userauth_kbdint() call and must not be freed.
</p>

</div>

<h5><a name="void_ssh_userauth_kbdint_setanswer_ssh_session_session_unsigned_int_i_char_answer" id="void_ssh_userauth_kbdint_setanswer_ssh_session_session_unsigned_int_i_char_answer">void ssh_userauth_kbdint_setanswer(SSH_SESSION *session, unsigned int i, char *answer);</a></h5>
<div class="level5">

<p>
 This function sets the ith answer. The string you give will be duplicated, and this copy will be discarded once it is no longer necessary.<br/>
 Care must be taken so you discard the content of the original string after this function call.<br/>

</p>

</div>

<h5><a name="a_little_note_about_how_to_use_the_informations_from_keyboard-interactive_authentication" id="a_little_note_about_how_to_use_the_informations_from_keyboard-interactive_authentication">A little note about how to use the informations from keyboard-interactive authentication</a></h5>
<div class="level5">

<p>
 The words from the original drafts explain everything better than I could
</p>
<pre class="code">3.3 User Interface Upon receiving a request message, the client SHOULD prompt the user as follows:
A command line interface (CLI) client SHOULD print the name and instruction (if non-empty), adding newlines.
Then for each prompt in turn, the client SHOULD display the prompt and read the user input.

A graphical user interface (GUI) client has many choices on how to prompt the user. One possibility is to use 
the name field (possibly prefixed with the application's name) as the title of a dialog window in which 
the prompt(s) are presented. In that dialog window, the instruction field would be a text message, and the
prompts would be labels for text entry fields. All fields SHOULD be presented to the user, for example an 
implementation SHOULD NOT discard the name field because its windows lack titles; it SHOULD instead find another 
way to display this information. If prompts are presented in a dialog window, then the client SHOULD NOT
present each prompt in a separate window.

All clients MUST properly handle an instruction field with embedded newlines. They SHOULD also be able to display
at least 30 characters for the name and prompts. If the server presents names or prompts longer than 30
characters, the client MAY truncate these fields to the length it can display. If the client does truncate any
fields, there MUST be an obvious indication that such truncation has occured.

The instruction field SHOULD NOT be truncated.
Clients SHOULD use control character filtering as discussed in [SSH-ARCH] to avoid attacks by including terminal
control characters in the fields to be displayed.

For each prompt, the corresponding echo field indicates whether or not the user input should be echoed as 
characters are typed. Clients SHOULD correctly echo/mask user input for each prompt independently of other 
prompts in the request message. If a client does not honor the echo field for whatever reason, then the client 
MUST err on the side of masking input. A GUI client might like to have a checkbox toggling echo/mask. Clients
SHOULD NOT add any additional characters to the prompt such as &quot;: &quot; (colon-space); the server is responsible for
supplying all text to be displayed to the user. Clients MUST also accept empty responses from the user and pass
them on as empty strings.</pre>

</div>

<h3><a name="none" id="none">&quot;none&quot;</a></h3>
<div class="level3">

<p>
 In fact this mode only serve to get the list of supported authentications, or to be authenticated <strong>without</strong> any credental. It happens on anonymous services for an example.<br/>
 It also serves to get the banner message from the server, if any. You should always firstly try this method, at least for getting the banner, then to enter if there is no password at all.
</p>

</div>

<h5><a name="int_ssh_userauth_none_ssh_session_session_char_username" id="int_ssh_userauth_none_ssh_session_session_char_username">int ssh_userauth_none(SSH_SESSION *session, char *username);</a></h5>
<div class="level5">

<p>
if the account has no password (and the server is configured to let you pass), the function might answer <acronym title="Secure Shell">SSH</acronym>_AUTH_SUCCESS. That&rsquo;s why ssh_auth_autopubkey already calls it for you.
</p>

</div>

<h5><a name="char_ssh_get_issue_banner_ssh_session_session" id="char_ssh_get_issue_banner_ssh_session_session">char *ssh_get_issue_banner(SSH_SESSION *session);</a></h5>
<div class="level5">

<p>
 If, during authentication, the server has given a banner, you can get it this way. the function returns NULL if no banner exists, and you have to free the returned pointer.
</p>

</div>

<h2><a name="opening_a_channel" id="opening_a_channel">4- Opening a channel</a></h2>
<div class="level2">

<p>
 Maybe you want to use the sftp subsystem : all this is done for you, you better read at the end of the paper how to use the sftp functions.<br/>
 You probably want to open one or more shells, or call one or more programs.<br/>
 So you need a channel.
</p>

</div>

<h5><a name="channel_channel" id="channel_channel">CHANNEL *channel;</a></h5>
<div class="level5">

<p>
This is an handler to a channel object. it describes your channel.
</p>

</div>

<h5><a name="channel_channel_open_session_ssh_session_session" id="channel_channel_open_session_ssh_session_session">CHANNEL *channel_open_session(SSH_SESSION *session);</a></h5>
<div class="level5">

<p>
This will open a channel for use into a session (which can be used for executing a command or a shell. Not for tcp forwarding).<br/>
 The function returns NULL if for a reason or another the channel can&rsquo;t be opened.<br/>

</p>

</div>

<h5><a name="channel_open_session_channel_..._is_deprecated_and_should_not_be_used_in_future_applications" id="channel_open_session_channel_..._is_deprecated_and_should_not_be_used_in_future_applications">CHANNEL *open_session_channel(...) is deprecated and should not be used in future applications.</a></h5>
<div class="level5">

</div>

<h5><a name="channel_channel_open_forward_ssh_session_session_char_remotehost_int_remoteport_char_sourcehost_int_localport" id="channel_channel_open_forward_ssh_session_session_char_remotehost_int_remoteport_char_sourcehost_int_localport">CHANNEL *channel_open_forward(SSH_SESSION *session, char *remotehost, int remoteport, char *sourcehost, int localport);</a></h5>
<div class="level5">

<p>
Ask the server to tunnel a TCP connection. The server will connect to remotehost:remoteport and libssh will return an handle to the channel if it is allowed. <br/>
 Otherwise, NULL will be returned. sourcehost and localport are generaly used in message debugging purpose and have no effect on the result.<br/>

</p>

<p>
 When you&rsquo;ve finished with your channel, you may send an <acronym title="End of file">EOF</acronym> message and then close it : 
</p>

</div>

<h5><a name="void_channel_send_eof_channel_channel" id="void_channel_send_eof_channel_channel">void channel_send_eof(CHANNEL *channel);</a></h5>
<div class="level5">

<p>
sends an end of file into channel. It doesn&rsquo;t close the channel and you can still read its content.
</p>

</div>

<h5><a name="void_channel_free_channel_channel" id="void_channel_free_channel_channel">void channel_free(CHANNEL *channel);</a></h5>
<div class="level5">

<p>
closes and destroy the channel.
</p>

</div>

<h5><a name="void_channel_close_channel_channel" id="void_channel_close_channel_channel">void channel_close(CHANNEL *channel);</a></h5>
<div class="level5">

<p>
 sends an <acronym title="End of file">EOF</acronym> and close the channel. (if you don&rsquo;t know what to do, use channel_free). It doesn&rsquo;t free the channel.
</p>

</div>

<h2><a name="the_shell" id="the_shell">5- The shell</a></h2>
<div class="level2">

<p>
 All these request may be refused by the server. In that case, the function will return -1. You should use <code>ssh_get_error_code(<acronym title="Secure Shell">SSH</acronym>_SESSION *session)</code> to get the error code. A denied request is
</p>
<pre class="code">SSH_REQUEST_DENIED</pre>

</div>

<h5><a name="int_channel_request_env_channel_channel_char_name_char_value" id="int_channel_request_env_channel_channel_char_name_char_value">int channel_request_env(CHANNEL *channel, char *name, char *value);</a></h5>
<div class="level5">

<p>
Ask the server to set the &ldquo;name&rdquo; environment variable to &ldquo;value&rdquo;. For security reasons, some variables won&rsquo;t be accepted by the server. It returns 0 otherwise.
</p>

</div>

<h5><a name="int_channel_request_pty_channel_channel" id="int_channel_request_pty_channel_channel">int channel_request_pty(CHANNEL *channel);</a></h5>
<div class="level5">

<p>
ask the server to allocate a pseudo terminal for the current channel.<br/>
 the function returns 0 on success.
</p>

</div>

<h5><a name="int_channel_request_pty_size_channel_channel_char_terminal_int_cols_int_rows" id="int_channel_request_pty_size_channel_channel_char_terminal_int_cols_int_rows">int channel_request_pty_size(CHANNEL *channel, char *terminal, int cols, int rows);</a></h5>
<div class="level5">

<p>
ask the server to allocate a pty. The terminal parameter is the type of pty (vt100,xterm,...), cols and rows are the size of the new terminal (80&times;24 by example).<br/>

</p>

</div>

<h5><a name="int_channel_change_pty_size_channel_channel_int_cols_int_rows" id="int_channel_change_pty_size_channel_channel_int_cols_int_rows">int channel_change_pty_size(CHANNEL *channel, int cols,int rows);</a></h5>
<div class="level5">

<p>
changes the window size (terminal) of the current session;
</p>

</div>

<h5><a name="int_channel_request_shell_channel_channel" id="int_channel_request_shell_channel_channel">int channel_request_shell(CHANNEL *channel);</a></h5>
<div class="level5">

<p>
This function requests a shell. After its success, a shell is running at the other side of the channel.
</p>

</div>

<h5><a name="int_channel_request_exec_channel_channel_char_cmd" id="int_channel_request_exec_channel_channel_char_cmd">int channel_request_exec(CHANNEL *channel, char *cmd);</a></h5>
<div class="level5">

<p>
run a shell command without an interactive shell, ie $SHELL -c &ldquo;command&rdquo;.<br/>
 returns 0 on success.<br/>

</p>

<p>
You might ask the server to open a subsystem for you. this is done this way :  
</p>

</div>

<h5><a name="int_channel_request_subsystem_channel_channel_char_subsystem" id="int_channel_request_subsystem_channel_channel_char_subsystem">int channel_request_subsystem(CHANNEL *channel, char *subsystem);</a></h5>
<div class="level5">

<p>
There are some functions used to manipulate the channels :
</p>

</div>

<h5><a name="int_channel_write_channel_channel_void_data_int_len" id="int_channel_write_channel_channel_void_data_int_len">int channel_write(CHANNEL *channel,void *data,int len);</a></h5>
<div class="level5">

<p>
writes len bytes of data into the channel. It returns the number of bytes written. The current implementation is a blocking write of the complete data buffer, but it may vary.
</p>

</div>

<h5><a name="int_channel_read_channel_channel_buffer_buffer_int_bytes_int_is_stderr" id="int_channel_read_channel_channel_buffer_buffer_int_bytes_int_is_stderr">int channel_read(CHANNEL *channel, BUFFER *buffer,int bytes,int is_stderr);</a></h5>
<div class="level5">

<p>
It makes a blocking read on the channel, of &ldquo;bytes&rdquo; bytes and returns the result into an allocated buffer you passed in. (with buffer_new()).<br/>
 it will read on stderr, if is_stderr is set.<br/>
 The function might read less bytes than &ldquo;bytes&rdquo; variable if an End of File happened. Otherwise, the function will always block reading until &ldquo;bytes&rdquo; bytes are read.<br/>
 with &ldquo;bytes&rdquo;=0, channel_read() will read the current state of the read buffer, but will read at least one byte (and block if nothing is available, except <acronym title="End of file">EOF</acronym> case).<br/>
 You don&rsquo;t need to free and allocate a new buffer each time you call this function, just pass the same object each time.<br/>
 Look at the buffer_ functions further for the correct way of retrieving the data.<br/>
 (This function will change with release 0.2)
</p>

</div>

<h5><a name="int_channel_read_nonblocking_channel_channel_char_dest_int_len_int_is_stderr" id="int_channel_read_nonblocking_channel_channel_char_dest_int_len_int_is_stderr">int channel_read_nonblocking (CHANNEL *channel, char *dest, int len, int is_stderr);</a></h5>
<div class="level5">

<p>
Non-blocking read on channel, at most len bytes of data are read. Returns 0 if <acronym title="End of file">EOF</acronym> or if no data available.
</p>

</div>

<h5><a name="int_channel_is_open_channel_channel" id="int_channel_is_open_channel_channel">int channel_is_open(CHANNEL *channel);</a></h5>
<div class="level5">

<p>
returns 0 if the channel has been closed by remote host, something else otherwise.
</p>

</div>

<h5><a name="int_channel_poll_channel_channel_int_is_stderr" id="int_channel_poll_channel_channel_int_is_stderr">int channel_poll(CHANNEL *channel, int is_stderr);</a></h5>
<div class="level5">

<p>
This nonblocking function returns the number of bytes immediatly available for reading on the channel and stdin/stderr.
</p>

<p>
More interesting, if you are going to do channel multiplexing, this function is for you :
</p>

</div>

<h5><a name="int_ssh_select_channel_channels_channel_outchannels_int_maxfd_fd_set_readfds_struct_timeval_timeout" id="int_ssh_select_channel_channels_channel_outchannels_int_maxfd_fd_set_readfds_struct_timeval_timeout">int ssh_select(CHANNEL **channels,CHANNEL **outchannels, int maxfd, fd_set *readfds, struct timeval *timeout);</a></h5>
<div class="level5">

<p>
channels is an array of channel pointers, finished by a NULL pointer. It can be used ever and ever, as it is never written.<br/>
 <code>outchannels</code> is an array of size at least greater or equal to &ldquo;channels&rdquo;.<br/>
 It hasn&rsquo;t to be initialized.<br/>
 <code>maxfd</code> is the maximum file descriptor from your own filedescriptors.<br/>
 <code>readfds</code> is a pointer to a fd_set structure, like in the original select implementation (man select).<br/>
 <code>struct timeval *timeout</code> has the same meaning than in select(2) (man select).<br/>
 There is no support for writing or special events as in select(2) yet.<br/>
 The function returns -1 if an error occured, or <acronym title="Secure Shell">SSH</acronym>_EINTR if select was interrupted by a syscall. This is not an error, you may restart the function.<br/>
 note about signals: libssh is not threadsafe, and most functions are not reetrant when using the same data structures : it means you *cannot* do anything with a channel from a ssh session passed to ssh_select during a signal.<br/>
 take a look at sample.c on how to bypass that limitation.<br/>
 the function works this way : it returns in the readfds the filedescriptors which have data ready for reading (the given filedescriptors have a greatest priority).<br/>
 Then, if no file descriptor can be read, the function looks for every channel from the array to get a channel with data bufferized. If nothing is available, it waits for activity on any channel/file descriptor and returns immediatly, or waits until timeout.<br/>
 You will find the channels that can be read in the outchannels array (finished by NULL) and the filedescriptors in your fd_set (man FD_ISSET).<br/>
 this is the &ldquo;heart&rdquo; of your main loop.<br/>

</p>

</div>

<h5><a name="the_buffer_object" id="the_buffer_object">The BUFFER object.</a></h5>
<div class="level5">

<p>
Reading is done through the BUFFER object. This object won&rsquo;t be available anymore with release 0.2.<br/>
 Here is the public interface : 
</p>

</div>

<h5><a name="buffer_buffer_new" id="buffer_buffer_new">BUFFER *buffer_new();</a></h5>
<div class="level5">

<p>
creates a buffer object.
</p>

</div>

<h5><a name="void_buffer_get_buffer_buffer" id="void_buffer_get_buffer_buffer">void *buffer_get(BUFFER *buffer);</a></h5>
<div class="level5">

<p>
returns a pointer to the begining of buffer.
</p>

</div>

<h5><a name="int_buffer_get_len_buffer_buffer" id="int_buffer_get_len_buffer_buffer">int buffer_get_len(BUFFER *buffer);</a></h5>
<div class="level5">

<p>
returns buffer&rsquo;s data size.
</p>

</div>

<h5><a name="void_buffer_free_buffer_buffer" id="void_buffer_free_buffer_buffer">void buffer_free(BUFFER *buffer);</a></h5>
<div class="level5">

<p>
destoys the buffer.
</p>

</div>

<h5><a name="how_to_use_the_buffer_system_when_you_ve_read_something" id="how_to_use_the_buffer_system_when_you_ve_read_something">How to use the buffer system when you've read something</a></h5>
<div class="level5">

<p>
I&rsquo;ve seen people doing such code:
</p>
<pre class="code">char buffer[256];
channel_read(channel,buf,1234,0);
strcpy(buffer,buf.data);</pre>

<p>
No.<br/>
 The correct way of doing this:<br/>

</p>
<pre class="code">char buffer[256];
int i;
i=channel_read(channel,buf,1234,0);
if(i&lt;=0)
  go_out()...
if(i&gt;=256)
  i=255;
memcpy(buffer,buffer_get(buf),i);
buffer[i]=0;</pre>

<p>
 Do not expect the buffer to be null-terminated. Don&rsquo;t access the internal structure of buffer. Check the sizes before copying.
</p>

</div>

<h2><a name="the_sftp_subsystem" id="the_sftp_subsystem">6- The SFTP subsystem</a></h2>
<div class="level2">

<p>
 SFTP is a secure implementation of a file transfer protocol. The current implemented version is 3. All functions aren&rsquo;t implemented yet but the most important are.
</p>

</div>

<h3><a name="a_opening_the_session" id="a_opening_the_session">A) Opening the session</a></h3>
<div class="level3">

</div>

<h5><a name="sftp_session_sftp_new_ssh_session_session" id="sftp_session_sftp_new_ssh_session_session">SFTP_SESSION *sftp_new(SSH_SESSION *session);</a></h5>
<div class="level5">

</div>

<h5><a name="int_sftp_init_sftp_session_sftp" id="int_sftp_init_sftp_session_sftp">int sftp_init(SFTP_SESSION *sftp);</a></h5>
<div class="level5">

<p>
The former returns a SFTP_SESSION handle. It returns NULL if things didn&rsquo;t work as expected.<br/>
 sftp_init makes some initialisation work. It returns 0 if things went right. Both of them must be called.
</p>

</div>

<h3><a name="b_opening_and_reading_a_directory" id="b_opening_and_reading_a_directory">B) Opening and reading a directory</a></h3>
<div class="level3">

<p>
 SFTP_DIR *sftp_opendir(SFTP_SESSION *session, char *path); opens a directory for file listing. Returns NULL in error case.
</p>

<p>
SFTP_ATTRIBUTES *sftp_readdir(SFTP_SESSION *session, SFTP_DIR *dir); This function reads one file attribute from an opened directory. It returns NULL if the directory is <acronym title="End of file">EOF</acronym>, or if something wrong happened.
</p>

<p>
int sftp_dir_eof(SFTP_DIR *dir); When a sftp_readdir() returned NULL, you can use this function to tell if an <acronym title="End of file">EOF</acronym> occured. the function returns 0 if no <acronym title="End of file">EOF</acronym> occured.
</p>

<p>
void sftp_attributes_free(SFTP_ATTRIBUTES *file); You have to free any SFTP_ATTRIBUTE structure given by an other function with it.
</p>

<p>
int sftp_dir_close(SFTP_DIR *dir); closes an opened directory. returns 0 when no error occured.
</p>

</div>

<h3><a name="c_opening_reading_writing_files" id="c_opening_reading_writing_files">C) Opening, reading, writing files</a></h3>
<div class="level3">

<p>
 SFTP_FILE *sftp_open(SFTP_SESSION *session, char *file, int access, SFTP_ATTRIBUTES *attr); Opens a file. The access flags are the same than the stdio flags. see open(2) for more details. attr are the wanted attributes for the new file. If you supply NULL, default values will be used. rem: more work is going on parsing/making the attributes structure
</p>

<p>
int sftp_read(SFTP_FILE *file, void *dest, int len); read on a file. Works as the fread() function. It is blocking by default but you can change the default behaviour with sftp_file_set_nonblocking().
</p>

<p>
void sftp_file_set_nonblocking(SFTP_FILE *file); sets the file non blocking. reads on this file won&rsquo;t ever block. You can&rsquo;t detect end of files this way. <strong>* TODO more work going there for <acronym title="End of file">EOF</acronym> </strong>**
</p>

<p>
void sftp_file_set_blocking(SFTP_FILE *file); restore the default setting of sftp_read.
</p>

<p>
int sftp_write(SFTP_FILE *file, void *source, int len); works as fwrite() function. It is a blocking write.
</p>

<p>
void sftp_seek(SFTP_FILE *file, int new_offset); seek into the file for reading/writing at an other place.
</p>

<p>
unsigned long sftp_tell(SFTP_FILE *file); returns the current offset (both writing and reading) into the opened file.
</p>

<p>
void sftp_rewind(SFTP_FILE *file); same as sftp_seek(file,0);
</p>

<p>
int sftp_file_close(SFTP_FILE *file); closes a file handle. returns 0 in no error case.
</p>

<p>
int sftp_rm(SFTP_SESSION *sftp, char *file); deletes a file.
</p>

<p>
int sftp_rmdir(SFTP_SESSION *sftp, char *directory);
</p>

<p>
deletes a directory.
</p>

<p>
int sftp_mkdir(SFTP_SESSION *sftp, char *directory, SFTP_ATTRIBUTES *attr); makes a directory, with the given attributes. You can&rsquo;t pass NULL for attr and hope it works.
</p>

<p>
int sftp_rename(SFTP_SESSION *sftp, char *original, char *newname); changes the name of a file or directory.
</p>

<p>
int sftp_setstat(SFTP_SESSION *sftp, char *file, SFTP_ATTRIBUTES *attr); changes the attributes of a file or directory.
</p>

<p>
char *sftp_canonicalize_path(SFTP_SESSION *sftp, char *path); gives the canonicalized form of some path. You have to free the pointer given in return. (returns NULL if error).
</p>

<p>
(a function to make proper SFTP_ATTRIBUTES structures is on the way )
</p>

</div>

<h3><a name="d_closing_the_session" id="d_closing_the_session">D) Closing the session</a></h3>
<div class="level3">

<p>
 void sftp_free(SFTP_SESSION *sftp); it closes the sftp channel and subsystem. 7- Handling the errors When some function returns an error code, it&rsquo;s allways possible to get an english message describing the problem. the function ssh_get_error() returns a pointer to the static error buffer. ssh_error_code() returns the error code number. it&rsquo;s declared as an enum: <acronym title="Secure Shell">SSH</acronym>_NO_ERROR, <acronym title="Secure Shell">SSH</acronym>_REQUEST_DENIED, <acronym title="Secure Shell">SSH</acronym>_INVALID_REQUEST, <acronym title="Secure Shell">SSH</acronym>_CONNECTION_LOST, <acronym title="Secure Shell">SSH</acronym>_FATAL, <acronym title="Secure Shell">SSH</acronym>_INVALID_DATA.
</p>

<p>
<acronym title="Secure Shell">SSH</acronym>_REQUEST_DENIED means the ssh server refused your request but the situation is recoverable. the others mean something happened to the connection (some encryption problems, server problems, library bug, ...). <acronym title="Secure Shell">SSH</acronym>_INVALID_REQUEST means the library got some garbage from server. (But might be recoverable). <acronym title="Secure Shell">SSH</acronym>_FATAL means the connection has an important problem and isn&rsquo;t probably recoverable.
</p>

<p>
Most of time, the error returned are <acronym title="Secure Shell">SSH</acronym>_FATAL, but some functions (generaly the ssh_request_* ones) may fail because of server denying request. In these cases, <acronym title="Secure Shell">SSH</acronym>_REQUEST_DENIED is returned.
</p>

<p>
You&rsquo;ll see in the prototype <acronym title="Secure Shell">SSH</acronym>_SESSION *session. That&rsquo;s because for thread safety, error messages that can be attached to a session aren&rsquo;t static anymore. So, any error that could happen during ssh_getopt(), options_* or ssh_connect() will be retreavable giving NULL as argument.
</p>

<p>
char *ssh_get_error(<acronym title="Secure Shell">SSH</acronym>_SESSION *session); returns a pointer to a static message error from the given session. No message freeing is needed.
</p>

<p>
enum ssh_error ssh_get_error_code(<acronym title="Secure Shell">SSH</acronym>_SESSION *session); returns the error code that last happened along with the message.
</p>

</div>

<h2><a name="final_word" id="final_word">8- Final word</a></h2>
<div class="level2">

<p>
 I made this library because nothing in the Open source or free software community was existing yet. This project is a very personnal one as it&rsquo;s the first &ldquo;useful&rdquo; thing I ever wrote. I hope it fits your needs, but remember the experimental state of libssh : if something doesn&rsquo;t work, please mail me. If something lacks, please ask for it. If something stinks, please write a patch and send it !  
</p>

</div>

    <!-- wikipage stop -->
  </div>

  <div class="clearer">&nbsp;</div>

  
  <div class="stylefoot">

    <div class="meta">
      <div class="user">
              </div>
      <div class="doc">
        libssh/documentation.txt &middot; Last modified: 2006/11/07 17:46      </div>
    </div>

   
    <div class="bar" id="bar__bottom">
      <div class="bar-left" id="bar__bottomleft">
        <form class="button" method="post" action="/wiki/libssh:documentation"><div class="no"><input type="hidden" name="do" value="edit" /><input type="hidden" name="rev" value="" /><input type="submit" value="Show pagesource" class="button" accesskey="v" title="Show pagesource [ALT+V]" /></div></form>        <form class="button" method="get" action="/wiki/libssh:documentation"><div class="no"><input type="hidden" name="do" value="revisions" /><input type="submit" value="Old revisions" class="button" accesskey="o" title="Old revisions [ALT+O]" /></div></form>      </div>
      <div class="bar-right" id="bar__bottomright">
                                <form class="button" method="get" action="/wiki/libssh:documentation"><div class="no"><input type="hidden" name="do" value="login" /><input type="submit" value="Login" class="button" title="Login" /></div></form>        <form class="button" method="get" action="/wiki/libssh:documentation"><div class="no"><input type="hidden" name="do" value="index" /><input type="submit" value="Index" class="button" accesskey="x" title="Index [ALT+X]" /></div></form>        <a class="nolink" href="#dokuwiki__top"><input type="button" class="button" value="Back to top" onclick="window.scrollTo(0, 0)" title="Back to top" /></a>&nbsp;
      </div>
      <div class="clearer"></div>
    </div>

  </div>

</div>

<div class="footerinc">
  <a  href="/wiki/feed.php" title="Recent changes RSS feed"><img src="/wiki/lib/tpl/default/images/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" /></a>

  <a  href="http://creativecommons.org/licenses/by-nc-sa/2.0/" rel="license" title="Creative Commons License"><img src="/wiki/lib/tpl/default/images/button-cc.gif" width="80" height="15" alt="Creative Commons License" /></a>

  <a  href="https://www.paypal.com/xclick/business=andi%40splitbrain.org&amp;item_name=DokuWiki+Donation&amp;no_shipping=1&amp;no_note=1&amp;tax=0&amp;currency_code=EUR&amp;lc=US" title="Donate"><img src="/wiki/lib/tpl/default/images/button-donate.gif" alt="Donate" width="80" height="15" /></a>

  <a  href="http://www.php.net" title="Powered by PHP"><img src="/wiki/lib/tpl/default/images/button-php.gif" width="80" height="15" alt="Powered by PHP" /></a>

  <a  href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="/wiki/lib/tpl/default/images/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" /></a>

  <a  href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="/wiki/lib/tpl/default/images/button-css.png" width="80" height="15" alt="Valid CSS" /></a>

  <a  href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="/wiki/lib/tpl/default/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" /></a>



<!--

<rdf:RDF xmlns="http://web.resource.org/cc/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="">
   <dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
   <license rdf:resource="http://creativecommons.org/licenses/by-nc-sa/2.0/" />
</Work>

<License rdf:about="http://creativecommons.org/licenses/by-nc-sa/2.0/">
   <permits rdf:resource="http://web.resource.org/cc/Reproduction" />
   <permits rdf:resource="http://web.resource.org/cc/Distribution" />
   <requires rdf:resource="http://web.resource.org/cc/Notice" />
   <requires rdf:resource="http://web.resource.org/cc/Attribution" />
   <prohibits rdf:resource="http://web.resource.org/cc/CommercialUse" />
   <permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
   <requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
</License>

</rdf:RDF>

-->


</div>

<div class="no"><img src="/wiki/lib/exe/indexer.php?id=libssh%3Adocumentation&amp;1165910197" width="1" height="1" alt=""  /></div>
</body>
</html>
