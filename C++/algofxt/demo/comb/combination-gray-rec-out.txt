// output of ./demo/comb/combination-gray-rec-demo.cc:
// Description:
//% Generating all combinations in minimal-change order, recursive implementation.

arg 1: 7 == N  [Length of words]  default=7
arg 2: 3 == K  [Combinations (n choose k)]  default=3
arg 3: 0 == cq  [Whether to generate complement]  default=0
arg 4: 0 == rq  [Whether to reverse order]  default=0
   1:    { 0, 1, 2 }    111....
   2:    { 0, 2, 3 }    1.11...
   3:    { 1, 2, 3 }    .111...
   4:    { 0, 1, 3 }    11.1...
   5:    { 0, 3, 4 }    1..11..
   6:    { 1, 3, 4 }    .1.11..
   7:    { 2, 3, 4 }    ..111..
   8:    { 0, 2, 4 }    1.1.1..
   9:    { 1, 2, 4 }    .11.1..
  10:    { 0, 1, 4 }    11..1..
  11:    { 0, 4, 5 }    1...11.
  12:    { 1, 4, 5 }    .1..11.
  13:    { 2, 4, 5 }    ..1.11.
  14:    { 3, 4, 5 }    ...111.
  15:    { 0, 3, 5 }    1..1.1.
  16:    { 1, 3, 5 }    .1.1.1.
  17:    { 2, 3, 5 }    ..11.1.
  18:    { 0, 2, 5 }    1.1..1.
  19:    { 1, 2, 5 }    .11..1.
  20:    { 0, 1, 5 }    11...1.
  21:    { 0, 5, 6 }    1....11
  22:    { 1, 5, 6 }    .1...11
  23:    { 2, 5, 6 }    ..1..11
  24:    { 3, 5, 6 }    ...1.11
  25:    { 4, 5, 6 }    ....111
  26:    { 0, 4, 6 }    1...1.1
  27:    { 1, 4, 6 }    .1..1.1
  28:    { 2, 4, 6 }    ..1.1.1
  29:    { 3, 4, 6 }    ...11.1
  30:    { 0, 3, 6 }    1..1..1
  31:    { 1, 3, 6 }    .1.1..1
  32:    { 2, 3, 6 }    ..11..1
  33:    { 0, 2, 6 }    1.1...1
  34:    { 1, 2, 6 }    .11...1
  35:    { 0, 1, 6 }    11....1
ct=35
