// -*- C++ -*-
// automatically generated by autodoc

// ========== HEADER FILE src/fht/fht-default.h: ==========

// Default FHT implementations:
inline void fht(double *f, ulong ldn);

inline void fht(Complex *f, ulong ldn);

inline void fht0(double *f, ulong ldn);

inline void fht0(Complex *f, ulong ldn);

// ========== HEADER FILE src/fht/fht.h: ==========


// General format of arguments: (double *f, ulong ldn)
// f := pointer to data array,
// ldn := base 2 log of array length (length n=2**n)
//
// A routine some_func0(...) (note the '0')
// expects input data with upper half zeros ('zero padded' data).
//
// Data in the arrays without const modifier is generally modified.
//
// A comment 'aux' at the line end marks functions that are
// called by other routines and might not be of direct use
// for users of the library

// ----- SRCFILE=src/fht/fhtdit.cc: -----
// tuning parameter:
// define to use trig recurrence:
// (and possibly lose some precision, see below)
//#define USE_TRIG_REC
// with type 'long double' slight speed loss on my machine,
// with type 'double' little speed gain.

// tuning parameter:
#define  INITIAL_RADIX_16  1  // 0 or 1 (default)
//
#if  ( INITIAL_RADIX_16==1 )
//#warning 'FYI: INITIAL_RADIX_16 set in fht_dit(double *, ulong)'
#else
#warning 'INITIAL_RADIX_16 is NOT SET in fht_dit(double *, ulong)'
#endif

void fht_dit_core(double *f, ulong ldn); // aux
// Decimation in time (DIT) FHT.
// Input data must be in revbin_permuted order.
// ldn := base-2 logarithm of the array length.

void fht_dit(double *f, ulong ldn);
// Fast Hartley Transform.
// Split-radix decimation in time (DIT) algorithm.
// ldn := base-2 logarithm of the array length.

// ----- SRCFILE=src/fht/fhtdif.cc: -----
// tuning parameter:
// define to use trig recurrence:
// (and possibly lose some precision, see below)
//#define USE_TRIG_REC
// with type 'long double' slight speed loss on my machine,
// with type 'double' little speed gain.
//
#if defined USE_TRIG_REC
//#warning 'fht(double *, ulong) uses trig recursion'
#endif

// tuning parameter:
#define  FINAL_RADIX_16  1  // 0 or 1 (default)
//
#if  ( FINAL_RADIX_16==1 )
//#warning 'FYI: FINAL_RADIX_16 set in fht_dif(double *, ulong)'
#else
#warning 'FINAL_RADIX_16 is NOT SET in fht_dif(double *, ulong)'
#endif

void fht_dif_core(double *f, ulong ldn); // aux
// Decimation in frequency (DIF) FHT.
// Output data is in revbin_permuted order.
// ldn := base-2 logarithm of the array length.

void fht_dif(double *f, ulong ldn);
// Fast Hartley Transform
// Split-radix decimation in frequency (DIF) algorithm.
// ldn := base-2 logarithm of the array length.

// ----- SRCFILE=src/fht/cfhtdit.cc: -----
// tuning parameter:
// define to use trig recurrence:
// (and possibly lose some precision, see below)
//#define USE_TRIG_REC
// with type 'long double' slight speed loss on my machine,
// with type 'double' little speed gain.

// tuning parameter:
#define  INITIAL_RADIX_16  1  // 0 or 1 (default)
//
#if  ( INITIAL_RADIX_16==1 )
//#warning 'FYI: INITIAL_RADIX_16 set in fht_dit(double *, ulong)'
#else
#warning 'INITIAL_RADIX_16 is NOT SET in fht_dit(Complex *, ulong)'
#endif

void fht_dit_core(Complex *f, ulong ldn); // aux
// Decimation in time (DIT) FHT.
// Input data must be in revbin_permuted order.
// ldn := base-2 logarithm of the array length.

void fht_dit(Complex *f, ulong ldn);
// Fast Hartley Transform.
// Split-radix decimation in time (DIT) algorithm.
// ldn := base-2 logarithm of the array length.

// ----- SRCFILE=src/fht/cfhtdif.cc: -----
// tuning parameter:
// define to use trig recurrence:
// (and possibly lose some precision, see below)
//#define USE_TRIG_REC
// with type 'long double' slight speed loss on my machine,
// with type 'double' little speed gain.
//
#if defined USE_TRIG_REC
//#warning 'fht(double *, ulong) uses trig recursion'
#endif

// tuning parameter:
#define  FINAL_RADIX_16  1  // 0 or 1 (default)
//
#if  ( FINAL_RADIX_16==1 )
//#warning 'FYI: FINAL_RADIX_16 set in fht_dif(double *, ulong)'
#else
#warning 'FINAL_RADIX_16 is NOT SET in fht_dif(Complex *, ulong)'
#endif

void fht_dif_core(Complex *f, ulong ldn); // aux
// Decimation in frequency (DIF) FHT.
// Output data is in revbin_permuted order.
// ldn := base-2 logarithm of the array length.

void fht_dif(Complex *f, ulong ldn);
// Fast Hartley Transform
// Split-radix decimation in frequency (DIF) algorithm.
// ldn := base-2 logarithm of the array length.

// ----- SRCFILE=src/fht/fht0.cc: -----
// tuning parameter:
#if defined USE_TRIG_REC
//#warning 'FYI: fht0(double *, ulong) uses trig recursion'
#endif

// tuning parameter:
#define  INITIAL_RADIX_16  1  // 0 or 1 (default)
//
#if  ( INITIAL_RADIX_16==1 )
//#warning 'FYI: INITIAL_RADIX_16 set in fht0(double *, ulong)'
#else
#warning 'INITIAL_RADIX_16 is NOT SET in fht0(double *, ulong)'
#endif

void fht0_dit(double *f, ulong ldn);
// Fast Hartley Transform
// Version for zero padded data:
//   fr[k],fi[k] == 0  for  k=n/2 ... n-1
// ldn := base-2 logarithm of the array length.
// Split-radix decimation in time (DIT) algorithm.

// ----- SRCFILE=src/fht/cfht0.cc: -----
// tuning parameter:
#if defined USE_TRIG_REC
//#warning 'FYI: fht0(double *, ulong) uses trig recursion'
#endif

// tuning parameter:
#define  INITIAL_RADIX_16  1  // 0 or 1 (default)
//
#if  ( INITIAL_RADIX_16==1 )
//#warning 'FYI: INITIAL_RADIX_16 set in fht0(double *, ulong)'
#else
#warning 'INITIAL_RADIX_16 is NOT SET in fht0(Complex *, ulong)'
#endif

void fht0_dit(Complex *f, ulong ldn);
// Fast Hartley Transform
// Version for zero padded data:
//   fr[k],fi[k] == 0  for  k=n/2 ... n-1
// ldn := base-2 logarithm of the array length.
// Split-radix decimation in time (DIT) algorithm.

// ----- SRCFILE=src/fht/fhtdit2.cc: -----
void fht_depth_first_dit2(double *f, ulong ldn);
// Radix-2 decimation in time (DIT) FHT.
// Depth-first version.
// Compared to usual fht this one
// - does more trig computations
// - is (far) better memory local

void fht_dit2(double *f, ulong ldn);
// Radix-2 decimation in time (DIT) FHT.

// ----- SRCFILE=src/fht/fhtdif2.cc: -----
void fht_depth_first_dif2(double *f, ulong ldn);
// Radix-2 decimation in frequency (DIF) FHT
// Depth-first version.
// Compared to usual FHT this one
// - does more trig computations
// - is (far) better memory local

void fht_dif2(double *f, ulong ldn);
// Radix-2 decimation in frequency (DIF) FHT

// -------- Spectrum:
// ----- SRCFILE=src/fht/fhtspect.cc: -----
void fht_spectrum(double *f, ulong ldn, int phasesq/*=0*/);
// Compute power spectrum using FHT
// ldn := base-2 logarithm of the array length
// phasesq != 0  requests computation of phases
// phase[i] is in f[n-i]  (i=1...n/2-1)
// phase[0] == 0,  phase[n/2] == 0
// output is not normalized

// ========== HEADER FILE src/fht/fht2d.h: ==========

// -------- 2-dimensional transform:
// ----- SRCFILE=src/fht/skipfht.cc: -----
void skip_fht(double *f, ulong n, ulong d, double *w);
// Compute fast Hartley transform (FHT) of the n elements
//    [0], [d], [2d], [3d],..., [(n-1)*d]

void skip_fht0(double *f, ulong n, ulong d, double *w);
// Compute fast Hartley transform (FHT) of the n elements
//   [0], [d], [2d], [3d],..., [(n-1)*d]
// where the second have are zero.

// ----- SRCFILE=src/fht/twodimfht.cc: -----
void row_column_fht(double *f, ulong nr, ulong nc); // aux
// FHT over rows and columns.
// This is _not_ a 2-dimensional FHT.
// nr := number of rows
// nc := number of columns

void y_transform(double *f, ulong nr, ulong nc); // aux
// Transforms row-column-FHT to 2-dimensional FHT.
// Self-inverse.
// nr := number of rows
// nc := number of columns

void twodim_fht(double *f, ulong nr, ulong nc);
// 2-dimensional fast Hartley transform (FHT)
// nr := number of rows
// nc := number of columns

// ========== HEADER FILE src/fht/fhtloc2.h: ==========

void fht_loc_dif2_core(Type *f, ulong ldn);
// Fast Hartley transform (FHT).
// Recursive decimation in frequency (DIF) algorithm.
// Excellent performance for large array sizes.

void fht_loc_dit2_core(Type *f, ulong ldn);
// Fast Hartley transform (FHT).
// Recursive decimation in time (DIT) algorithm.
// Excellent performance for large array sizes.

// inlines give default implementations:
inline void fht_loc(Type *f, ulong ldn);

inline void fht0_loc(Type *f, ulong ldn);

// ========== HEADER FILE src/fht/hartleyshift.h: ==========

inline void hartley_shift_05_v1(Type *f, ulong n);
// Hartley transform analogue to fourier_shift(f, n, 0.5)
// n := length of array
// Used for negacyclic convolution and recursive FHTs.
// Self-inverse.

inline void hartley_shift_05_v1rec(Type *f, ulong n);
// Same as hartley_shift_05_v1() but with trigonometric recursion.

inline void hartley_shift_05_v2(Type *f, ulong n);
// Optimized version,  n must be a power of 2.

inline void hartley_shift_05_v2rec(Type *f, ulong n);
// Optimized version,  n must be a power of 2.
// Same as hartley_shift_05_v2() but with trigonometric recursion.

// inlines give default implementation:
inline void hartley_shift_05(Type *a, ulong n);

// ========== HEADER FILE src/fht/shortfhtdifcore.h: ==========

inline void fht_dif_core_2(Type *f);
// unrolled version for length 2

inline void fht_dif_core_4(Type *f);
// unrolled version for length 4

inline void fht_dif_core_8(Type *f);
// unrolled version for length 8

inline void fht_dif_core_16(Type *f);
// unrolled version for length 16

inline void fht_dif_core_32(Type *f);
// unrolled version for length 32

inline void fht_dif_core_64(Type *f);
// unrolled version for length 64

inline void fht_dif_core_leq_64(Type *f, ulong n);
// Must have n \in {2, 4, 8, 16, 32, 64}

// ========== HEADER FILE src/fht/shortfhtditcore.h: ==========

inline void fht_dit_core_2(Type *f);
// unrolled version for length 2

inline void fht_dit_core_4(Type *f);
// unrolled version for length 4

inline void fht_dit_core_8(Type *f);
// unrolled version for length 8

inline void fht_dit_core_16(Type *f);
// unrolled version for length 16

inline void fht_dit_core_32(Type *f);
// unrolled version for length 32

inline void fht_dit_core_64(Type *f);
// unrolled version for length 64

// ========== HEADER FILE src/fht/slowht.h: ==========

// -------- Slow algorithms:
// ----- SRCFILE=src/fht/slowht.cc: -----
void slow_ht(double *f, ulong n);
// (slow) Hartley transform.

void slow_ht(Complex *f, ulong n);
// (slow) Hartley transform.

void slow_row_column_ht(double *f, ulong nr, ulong nc);

void slow_twodim_ht(double *f, ulong nr, ulong nc);
// (slow) 2-dimensional Hartley transform.

// ----- SRCFILE=src/fht/recfht2.cc: -----
static void recursive_fht_dit2_core(const double *a, ulong n, double *x);

void recursive_fht_dit2(double *a, ulong ldn);
// Very inefficient, just to demonstrate the
// recursive fast Hartley transform

static void recursive_fht_dif2_core(const double *a, ulong n, double *x);

void recursive_fht_dif2(double *a, ulong ldn);
// Very inefficient, just to demonstrate the
// recursive fast Hartley transform

