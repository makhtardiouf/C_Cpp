// -*- C++ -*-
// automatically generated by autodoc

// ========== HEADER FILE src/correlation/correlation.h: ==========

// Real correlation
// ----- SRCFILE=src/correlation/fhtcorr.cc: -----
void fht_correlation(double * restrict f, double * restrict g, ulong ldn);
// compute the (real, cyclic) correlation of f[], g[]
// result is in g[]
// ldn := base-2 logarithm of the array length
// version for zero padded data:
//   f[k], g[k] == 0 for k=n/2 ... n-1
// n = 2**ldn  must be >=2

void fht_auto_correlation(double *f, ulong ldn);
// compute the (real, cyclic) self-correlation of f[]
// ldn := base-2 logarithm of the array length
// version for zero padded data:
//   f[k] == 0 for k=n/2 ... n-1
// n = 2**ldn  must be >=2

void fht_correlation0(double * restrict f, double * restrict g, ulong ldn);
// compute the (real, linear) correlation of f[], g[]
// result is in g[]
// ldn := base-2 logarithm of the array length
// version for zero padded data:
//   f[k], g[k] == 0 for k=n/2 ... n-1
// n = 2**ldn  must be >=2

void fht_auto_correlation0(double *f, ulong ldn);
// compute the (real, linear) self-correlation of f[]
// ldn := base-2 logarithm of the array length
// version for zero padded data:
//   f[k] == 0 for k=n/2 ... n-1
// n = 2**ldn  must be >=2

void fht_auto_correlation_core(double *f, ulong ldn,
                          double v/*=0.0*/);
// auxiliary routine for the computation of self-correlations
//   via Fast Hartley Transforms
// ldn := base-2 logarithm of the array length
// v!=0.0 chooses alternative normalization

// ----- SRCFILE=src/correlation/fftcorr.cc: -----
void fft_correlation(double *f, double *g, ulong ldn);
// Cyclic correlation of f[], g[], both real-valued sequences.
// Result is written to g[].
// ldn := base-2 logarithm of the array length
// n = 2**ldn  must be >=2

void fft_auto_correlation(double *f, ulong ldn);
// Cyclic self-correlation of f[], a real-valued sequence.
// ldn := base-2 logarithm of the array length
// n = 2**ldn  must be >=2

void fft_correlation0(double *f, double *g, ulong ldn);
// Linear correlation of f[], g[], two real-valued sequences.
// Result is written to g[].
// Version for zero padded data:
//   f[k], g[k] == 0 for k=n/2 ... n-1
// ldn := base-2 logarithm of the array length
// n = 2**ldn  must be >=2

void fft_auto_correlation0(double *f, ulong ldn);
// Linear self-correlation of f[], a real-valued sequence.
// Version for zero padded data:
//   f[k] == 0 for k=n/2 ... n-1
// ldn := base-2 logarithm of the array length
// n = 2**ldn  must be >=2

// Complex correlation
// ----- SRCFILE=src/correlation/fftcocorr.cc: -----
void fft_complex_auto_correlation(double * restrict fr, double * restrict fi, ulong ldn);
// Complex (cyclic) self-correlation
// (use zero padded data for linear correlation)
// ldn := base-2 logarithm of the array length

void fft_complex_correlation(double * restrict fr, double * restrict fi,
                        double * restrict gr, double * restrict gi,
                        ulong ldn);
// Complex (cyclic) correlation of fr, fi with gr, gi
// (use zero padded data for linear convolution)
// ldn := base-2 logarithm of the array length
// Result in gr, gi

// ----- SRCFILE=src/correlation/slowcocorr.cc: -----
void slow_complex_correlation(const double *fr, const double *fi,
                         const double *gr, const double *gi,
                         double *hr, double *hi,
                         ulong n);
// (cyclic, complex) correlation:  (hr, hi)[] :=  (fr,fi)[] (c) (gr,gi)[]
// (use zero padded data for linear correlation)

void slow_complex_correlation(const double *fr, const double *fi,
                         double *gr, double *gi, ulong n);
// (cyclic, complex) correlation:  (gr, gi)[] :=  (fr,fi)[] (c) (gr,gi)[]
// (use zero padded data for linear correlation)

void slow_complex_auto_correlation(double *fr, double *fi, ulong n);
// (cyclic, complex) self-correlation:  (gr, gi)[] :=  (fr,fi)[] (c) (fr,fi)[]
// (use zero padded data for linear correlation)

// ========== HEADER FILE src/correlation/slowcorr.h: ==========

void slow_correlation(const Type *f, const Type *g, Type * restrict h, ulong n);
// Cyclic correlation of f[], g[], both real-valued sequences.
// n := array length
// slow_correlation(f, g, h, n)  =^=
// { reverse_0(g, n); slow_convolution(f, g, h, n); reverse_0(g, n); }

void slow_correlation0(const Type *f, const Type *g, Type * restrict h, ulong n);
// Linear correlation of f[], g[], both real-valued sequences.
// n := array length
// Version for zero padded data:
//   f[k],g[k] == 0 for k=n/2 ... n-1
// n must be >=2

void slow_auto_correlation(const Type *f, Type * restrict g, ulong n);
// Cyclic self-correlation of f[], a real-valued sequence.
// Result is written to g[].
// n := array length

void slow_auto_correlation0(const Type *f, Type * restrict g, ulong n);
// Linear self-correlation of f[], a real-valued sequence.
// n := array length
// Result is written to g[].
// Input data must be zero padded:
//   f[n/2] .. f[n-1] == 0 and g[n/2] .. g[n-1] == 0
// n  must be >=2

void slow_correlation(const Type *f, Type * restrict g, ulong n);
// Cyclic correlation of f[], g[], two real-valued sequences.
// n := array length

void slow_correlation0(const Type *f, Type * restrict g, ulong n);
// Linear correlation of f[], g[], two real-valued sequences.
// Result is written to g[].
// n := array length
// Input data must be zero padded:
//   f[n/2] .. f[n-1] == 0 and g[n/2] .. g[n-1] == 0
// n  must be >=2

void slow_auto_correlation(Type *f, ulong n);
// Cyclic self-correlation of f[], a real-valued sequence.
// n := array length

void slow_auto_correlation0(Type *f, ulong n);
// Linear self-correlation of f[], a real-valued sequence.
// n := array length
// Input data must be zero padded:
//   f[n/2] .. f[n-1] == 0
// n  must be >=2

