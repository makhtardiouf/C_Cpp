// -*- C++ -*-
// automatically generated by autodoc

// ========== HEADER FILE src/aux1/arith1.h: ==========

inline void negate(Type *f, ulong n);
// negate every element of f[]

inline void multiply_val(Type *f, ulong n, Type s);
// f[] *= s

inline void add(Type *f, ulong n, const Type *g);
// f[] += g[] element-wise

inline void subtract(Type *f, ulong n, const Type *g);
// f[] -= g[] element-wise

inline void multiply(Type *f, ulong n, const Type *g);
//  f[] *= g[] element-wise

// ========== HEADER FILE src/aux1/bytescan.h: ==========

// ----- SRCFILE=src/aux1/bytescan.cc: -----
ulong long_strlen(const char *str);
// Return length of string starting at str.

// ========== HEADER FILE src/aux1/copy.h: ==========

inline void memzero(Type *dst, ulong n);
// Set array (memory) to zero (bytes).

inline void fill(Type *dst, ulong n, Type v);
// Fill array with value v

inline void null(Type *dst, ulong n);
// Set array to zero.
// If the element zero consists of zero bytes only,
// then prefer memzero().

inline void memcopy(const Type *src, Type *dst, ulong n);
// Copy array (memory) src[] to dst[]

inline void acopy(const Type *src, Type *dst, ulong n);
// Copy array src[] to dst[]
// Named acopy() to avoid conflict with std::copy()

inline void copy_cast(const Type1 *src, Type2 *dst, ulong n);
// Copy array src[] to dst[]

inline void copy0(const Type1 *src, ulong ns,;
                  Type2 *dst, ulong nd)
// Copy as much as makes sense, fill rest with zeros
// from src[] (length ns) to dst[] (length nd).

inline void copy_cyclic(const Type *src, Type *dst, ulong n, ulong s);
// Copy array src[] to dst[]
// starting from position s in src[]
// wrap around end of src[]  (src[n-1])
//
// src[] is assumed to be of length n
// dst[] must be of length n at least
//
// Equivalent to:  { acopy(src, dst, n); rotate_right(dst, n, s); }

inline void skip_copy(const Type *src, Type *dst, ulong n, ulong d);
// Copy n elements from src[] at positions
//   [0],[d],[2d],[3d],...,[(n-1)*d]
//   to dst[0, 1, ..., n-1]

inline void skip_copy_back(const Type *src, Type *dst, ulong n, ulong d);
// Copy n elements from src[0, 1, ..., n-1]
//   to dst[] at positions
//   [0],[d],[2d],[3d],...,[(n-1)*d]

inline void swap(Type *f, Type *g, ulong n);
// Swap arrays

inline void set_seq(Type *dst, ulong n, Type start=0, Type step=1);
// Fill array with sequence
//   start, start+step, start+2*step, ...

// ========== HEADER FILE src/aux1/norm.h: ==========

static inline double scalar_product(const double *f, const double *g, ulong n);

static inline double norm_sqr(const double *f, ulong n);

static inline double norm_l2(const double *f, ulong n);

static inline void normalize_l2(double *f, ulong n);

static inline Complex scalar_product(const Complex *f, const Complex *g, ulong n);

static inline double norm_sqr(const Complex *f, ulong n);

static inline double norm_l2(const Complex *f, ulong n);

static inline void normalize_l2(Complex *f, ulong n);

// ========== HEADER FILE src/aux1/num2str.h: ==========

// ----- SRCFILE=src/aux1/num2str.cc: -----
void num2str(ulong x, ulong rd, char *str);
// Write radix-rd representation of x to str[].
// Must have rd <= 36.

// ========== HEADER FILE src/aux1/shift.h: ==========

inline void shift_right(Type *f, ulong n, ulong s);
// Shift elements s positions away from element zero.

inline void shift_left(Type *f, ulong n, ulong s);
// Shift elements s positions towards element zero.

inline void shift_right1(Type *f, ulong n);
// Shift elements 1 position away from element zero.

inline void shift_left1(Type *f, ulong n);
// Shift elements 1 position towards element zero.

// ========== HEADER FILE src/aux1/wordgray.h: ==========


// Word-wise Gray code and reversed Gray code.
// cf. bits/graycode.h and bits/graypower.h

void word_gray(Type *f, ulong n);

void inverse_word_gray(Type *f, ulong n);

void word_gray_pow(Type *f, ulong n, ulong x);
// result is identical to
//   for (ulong k=0; k<x; ++k)  word_gray(f, n);
// Work <= n/2

void word_rev_gray(Type *f, ulong n);

void inverse_word_rev_gray(Type *f, ulong n);

void word_rev_gray_pow(Type *f, ulong n, ulong x);
// result is identical to
//   for (ulong k=0; k<x; ++k)  word_rev_gray(f, n);
// work <= n/2

