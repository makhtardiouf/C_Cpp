// -*- C++ -*-
// automatically generated by autodoc

// ========== HEADER FILE src/ds/array2d.h: ==========

class array2d;

array2d<Type>::array2d(ulong nr, ulong nc, Type *f/*=0*/);
    : nc_(nc), nr_(nr)

array2d<Type>::array2d(ulong nr, ulong nc, Type **rowp);
    : nc_(nc), nr_(nr)

void copy(const array2d<Type1> &src,;
          array2d<Type2> &dst)

// ========== HEADER FILE src/ds/bitarray.h: ==========

class bitarray;
// Bit-array class mostly for use as memory saving array of Boolean values.
// Valid index is 0...nb_-1 (as usual in C arrays).

// ========== HEADER FILE src/ds/deque.h: ==========

class deque;
// deque := double-ended queue
// Can grow dynamically

// ========== HEADER FILE src/ds/heap.h: ==========

ulong test_heap(const Type *x, ulong n);
// Return 0 if x[] has heap property
// else index of node found to be greater than its parent.

void heapify(Type *z, ulong n, ulong k);
// Subject to the condition that the trees below the children of node
// k are heaps, move the element z[k] (down) until the tree below node k is a heap.
// Data expected in z[1,2,...,n].

void build_heap(Type *x, ulong n);
// Reorder data to a heap.
// Data expected in x[0,1,...,n-1].

bool heap_insert(Type *x, ulong n, ulong s, Type t);
// With x[] a heap of current size n
// and max size s (i.e. space for s elements allocated),
// insert t and restore heap-property.
// Return true if successful, else (i.e. if space exhausted) false.
// Complexity is O(log(n)).

Type heap_extract_max(Type *x, ulong n);
// Return maximal element of heap and restore heap structure.
// Return value is undefined for 0==n.

// ========== HEADER FILE src/ds/left-right-array.h: ==========

class left_right_array;
// Maintain index array [0,...,n-1], keep track which index is set or free.
// Allows, in time O(log(n)), to
// - find k-th free index (where 0<=k<=num_free())
// - find k-th set index (where 0<=k<=num_set())
// - determine how many indices are free/set to the left/right of
//   an absolute index i (where 0<=i<n).

// ========== HEADER FILE src/ds/priorityqueue.h: ==========


#if  1
// next() is the one with the smallest key
// i.e.  extract_next()  is  extract_min()
#define _CMP_ <
#define _CMPEQ_ <=
#else
// next() is the one with the biggest key
// i.e.  extract_next()  is  extract_max()
#define _CMP_ >
#define _CMPEQ_ >=
#endif

class priority_queue;
// Priority queue.
// Can grow dynamically.

// ========== HEADER FILE src/ds/queue.h: ==========

class queue;
// Implementation of a queue

// ========== HEADER FILE src/ds/ringbuffer.h: ==========

class ringbuffer;
// Implementation of a ring buffer

// ========== HEADER FILE src/ds/stack.h: ==========

class stack;

