// -*- C++ -*-
// automatically generated by autodoc

// ========== HEADER FILE src/bmat/bitmat-funcs.h: ==========

// ----- SRCFILE=src/bmat/bitmat-mult-mm.cc: -----
void bitmat_mult_MM(const ulong *M1, const ulong *M2, ulong n, ulong *P);
// Multiply binary (n x n) matrices:  P = M1 * M2.

// ----- SRCFILE=src/bmat/bitmat-transpose.cc: -----
void bitmat_transpose(const ulong *M, ulong n, ulong *T);
// Transpose binary (n x n) matrix M:  T = transpose(M).

// ----- SRCFILE=src/bmat/bitmat-nullspace.cc: -----
ulong bitmat_nullspace(const ulong *M, ulong n, ulong *Ns);
// Write basis of nullspace of M to Ns.
// M is a binary (n x n) matrix (elements over GF(2)).
// Return r, the number of vectors of the nullspace.
// 0<=r<=n  (r==n only for M==0)
// rank(M) = n-r

ulong bitmat_test_nullspace(const ulong *M, ulong n, const ulong *Ns, ulong r);
// (print and) check nullspace as returned by bitmat_nullspace()
// Return k<r if vector k is not in nullspace.

// ----- SRCFILE=src/bmat/bitmat-inverse.cc: -----
bool bitmat_inverse_q(const ulong *M, ulong n, const ulong *Mi);

bool bitmat_inverse(const ulong *M, ulong n,
               ulong * restrict Mi,
               const ulong * restrict B/*=0*/);
// Compute Mi=M^(-1)*B or Mi=M^(-1) if B not given.
// Return false if M is not invertible.

bool bitmat_invert(ulong *M, ulong n);

// ----- SRCFILE=src/bmat/bitmat-hessenberg.cc: -----
bool bitmat_is_hessenberg(const ulong *H, ulong n);
// Return true if H is in Hessenberg form, else false.

void bitmat_hessenberg(const ulong *M, ulong n, ulong *H);
// Set H to the Hessenberg form of M.

// ----- SRCFILE=src/bmat/bitmat-charpoly.cc: -----
ulong bitmat_hessenberg2charpoly(const ulong *H, ulong n);
// Return the characteristic polynomial of the Hessenberg matrix H

ulong bitmat_charpoly(const ulong *M, ulong n);
// Return the characteristic polynomial of M.

// ----- SRCFILE=src/bmat/bitmat-print.cc: -----
void bitmat_print(const char *bla, const ulong *M, ulong n, ulong nv/*=0*/);

// ----- SRCFILE=src/bmat/bitmat-kronecker.cc: -----
void bitmat_kronecker(const ulong *M1, ulong n1,
                 const ulong *M2, ulong n2,
                 ulong * restrict K);
// Set K = M1 (*) M2, where (*) denotes the Kronecker product.
// Must have n1*n2 <= BITS_PER_LONG.

// ========== HEADER FILE src/bmat/bitmat-inline.h: ==========

inline ulong bitmat_get(const ulong *M, ulong r, ulong c);
// Return entry M[r,c]

inline void bitmat_set(ulong *M, ulong r, ulong c, ulong v);
// Set M[r,c] = v

inline void bitmat_copy(const ulong *M1, ulong n, ulong *M2);
// M2 = M1 (for binary matrices)

inline void bitmat_unit(ulong *M, ulong n);
// M = unity

inline bool bitmat_is_unit(const ulong *M, ulong n);
// Return whether M equals unity.

inline bool bitmat_is_zero(const ulong *M, ulong n);
// Return whether M equals 0.

inline void bitmat_add_unit(ulong *M, ulong n);
// M += unity

inline ulong bitmat_trace(const ulong *M, ulong n);
// Return the trace of M.

inline bool bitmat_eq(const ulong *M1, const ulong *M2, ulong n);
// Return whether M1 equals M2.

inline ulong bitmat_mult_Mv(const ulong *M, ulong n, ulong v);
// Return M*v where
// M is a binary (n x n) matrix, v is a binary vector.

inline ulong bitmat_mult_vM(const ulong *M, ulong n, ulong v);
// Return v*M where
// M is a binary (n x n) matrix, v is a binary vector.

inline void bitmat_companion(ulong p, ulong n, ulong *M);
// Create companion matrix for the binary polynomial
// p(x) = x^n + \sum_{i=0}^{n-1}{c_i*x^i}

inline void bitmat_circulant(ulong v, ulong n, ulong *M);
// Create circulant matrix with rows that are cyclic shifts of v.

