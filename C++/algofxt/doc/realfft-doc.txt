// -*- C++ -*-
// automatically generated by autodoc

// ========== HEADER FILE src/realfft/realfft.h: ==========


// General format of arguments: (double *f, ulong ldn)
// f := pointer to data array,
// ldn := base 2 log of array length (length n=2**n)
//
// A function some_func0(...) (note the '0')
// expects input data with upper half zeros ('zero padded' data).
//
// Data in the arrays without const modifier is generally modified.
//
// A comment 'aux' at the line end marks functions that are
// called by other routines and might not be of direct use
// for users of the library

// ----- SRCFILE=src/realfft/realfftbyfht.cc: -----
void fht_real_complex_fft(double *f, ulong ldn, int is/*=+1*/);
// Real to complex FFT.
// Ordering of output:
// f[0]     = re[0]
// f[1]     = re[1]
// f[n/2-1] = re[n/2-1]
// f[n/2]   = re[n/2](==nyquist freq)
// f[n/2+1] = im[n/2-1]  (wrt. complex FFT with is=+1)
// f[n/2+2] = im[n/2-2]
// f[n-1]   = im[1]
// corresponding real and imag parts (with the exception of
// zero and nyquist freq) are found in f[i] and f[n-i]
// note that the order of imaginary parts
// is reversed wrt. fft_real_complex_fft()

void fht_real_complex_fft0(double *f, ulong ldn, int is/*=+1*/);
// Real to complex FFT.
// Version for zero padded data
// Ordering of output as with fht_real_complex_fft()

void fht_complex_real_fft(double *f, ulong ldn, int is/*=+1*/);
// Complex to real FFT.
// Inverse of fht_real_complex_fft() for _same_ sign of transform (is).
// Ordering of input like the output of fht_real_complex_fft()

void realisator(double *gr, const double *gi, ulong n, int is); // aux
// Let gr[], gi[] be the FFT of a complex sequence.
// realisator() isolates the part of the data corresponding
// to the real part of the original sequence in gr[]
// Using the code fragment:
// { realisator(gr, gi, n, is); fht_complex_real_fft(gr, ldn); }
// one would get (only) the real part of the original sequence in gr[]

void imaginator(const double *gr, double *gi, ulong n, int is); // aux
// Let gr[], gi[] be the FFT of a complex sequence.
// imaginator() isolates the part of the data corresponding
// to the imag part of the original sequence in gi[]
// Using the code fragment:
// { imaginator(gr, gi, n, is); fht_complex_real_fft(gi, ldn); }
// one gets (only) the imag part of the original sequence in gi[]

void separator(double *gr, double *gi, ulong n, int is); // aux
// Let gr[], gi[] be the FFT of a complex sequence.
// separator() isolates the parts of the data corresponding
// to the real/imag part of the original sequence in gr[]/gi[]
// Using the code fragment:
// { separator(gr, gi, n, is);
//  fht_complex_real_fft(gr, ldn); fht_complex_real_fft(gi, ldn); }
// one would get the real/imag parts of the original sequence in gr[]/gi[]

// ----- SRCFILE=src/realfft/realfftwrap.cc: -----
void wrap_real_complex_fft(double *f, ulong ldn/*, int is=+1*/);
// Real to complex FFT (R2CFT)
// Sign hard-coded to is=+1
// Ordering of output:
// f[0]     = re[0]   (DC part, purely real)
// f[1]     = re[n/2] (nyquist freq, purely real)
// f[2]     = re[1]
// f[3]     = im[1]
// f[4]     = re[2]
// f[5]     = im[2]
// f[2*i]   = re[i]
// f[2*i+1] = im[i]
// f[n-2]   = re[n/2-1]
// f[n-1]   = im[n/2-1]
// Equivalent to:
// { fht_real_complex_fft(f, ldn, is); zip(f, n); }

void wrap_complex_real_fft(double *f, ulong ldn/*, int is=+1*/);
// Complex to real FFT (C2RFT).
// Sign hard-coded to is=+1
// Inverse of wrap_real_complex_fft().
// Ordering of input is same as for
//   the output of wrap_real_complex_fft()

// ----- SRCFILE=src/realfft/realffteasyord.cc: -----
void easy_ordering_real_complex_fft(double *f, ulong ldn, int is/*=+1*/);
// isign = +1
// ordering of output is:
// f[0]     = re[0]
// f[1]     = re[1]
// f[n/2-1] = re[n/2-1]
// f[n/2]   = re[n/2] (==nyquist freq)
// f[n/2+1] = im[1]
// f[n/2+2] = im[2]
// f[n-1]   = im[n/2-1]
// corresponding real and imag parts (with the exception of
// zero and nyquist freq) are found in f[i] and f[n/2+i]

void easy_ordering_real_complex_fft0(double *f, ulong ldn, int is/*=+1*/);
// version for zero padded data
// ordering of output:
// see easy_ordering_real_complex_fft()

void easy_ordering_complex_real_fft(double *f, ulong ldn, int is/*=+1*/);
// isign = +1
// expected ordering of input:
// like the output of easy_ordering_real_complex_fft()

// ----- SRCFILE=src/realfft/realfftsplitradix.cc: -----
// tuning parameter:
#define  USE_SINCOS3  0  // 0 to use algebra (default) or 1 for sincos call
//
// sin & cos of triple angle by algebra:
#define SINCOS3ALG(c, s, c3, s3) \
{ c3 = 4.0*c*(c*c-0.75); s3=4.0*s*(0.75-s*s); }

void split_radix_real_complex_fft(double *x, ulong ldn, int is/*=-1*/);
// Transform length is n=2**ldn
// Ordering of output:
// f[0]     = re[0] (==zero frequency, purely real)
// f[1]     = re[1]
// f[n/2-1] = re[n/2-1]
// f[n/2]   = re[n/2]    (==nyquist frequency, purely real)
// f[n/2+1] = im[n/2-1]
// f[n/2+2] = im[n/2-2]
// f[n-1]   = im[1]
// Corresponding real and imag parts (with the exception of
// zero and nyquist freq) are found in f[i] and f[n-i]
// The order of imaginary parts is the same as in fht_real_complex_fft
// (reversed wrt. easy_ordering_real_complex_fft())

void split_radix_real_complex_fft0(double *x, ulong ldn, int is/*=-1*/);
// Version for zero padded arrays

void split_radix_complex_real_fft(double *x, ulong ldn, int is/*=-1*/);
// Transform length is n=2**ldn
// Ordering of input must be
// like the output of split_radix_real_complex_fft()

void split_radix_real_complex_fft_dit_core(double *x, ulong ldn); // aux
// Fixed isign == -1

void split_radix_complex_real_fft_dif_core(double *x, ulong ldn); // aux
// isign == -1

// ----- SRCFILE=src/realfft/skiprealfft.cc: -----
void skip_real_complex_fft(double *f, ulong n, ulong d, double *w); // aux
// Compute real to complex FFT of the n elements
// [0],[d],[2d],[3d],...,[(n-1)*d]

void skip_real_complex_fft0(double *f, ulong n, ulong d, double *w); // aux
// Compute real to complex FFT of the n elements
// [0],[d],[2d],[3d],...,[(n-1)*d]
// where the upper half are known to be zero.

void skip_complex_real_fft(double *f, ulong n, ulong d, double *w); // aux
// Compute complex to real FFT of the n elements
// [0],[d],[2d],[3d],...,[(n-1)*d]

// inlines give default implementations
inline void real_complex_fft(double *f, ulong ldn, int is);

inline void complex_real_fft(double *f, ulong ldn, int is);

