// -*- C++ -*-
// automatically generated by autodoc

// ========== HEADER FILE src/dctdst/dctdst.h: ==========

// cosine and sine transforms
// ----- SRCFILE=src/dctdst/cosrot.cc: -----
void cos_rot(const double *x, double *y, ulong n); // aux
// Auxiliary routine for dcth() and dct4()
// x and y may be identical
// Self-inverse.

// ----- SRCFILE=src/dctdst/dcth.cc: -----
void dcth(double *x, ulong ldn, double *tmp/*=0*/);
// transform wrt. basis:
//   cos( 2*Pi * 0.5 * k * (i+0.5)/n ) * (k==0?1.0:sqrt(2))
//   where k is the index of the basis
// the basis:
//  0: [* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *] ( 0)
//  1: [* * * * * * * * * * * * * * * *                                ] ( 1)
//  2: [* * * * * * * *                                 * * * * * * * *] ( 2)
//  3: [* * * * *                       * * * * * * * * * * *          ] ( 3)
//  4: [* * * *                 * * * * * * * *                 * * * *] ( 4)
//  5: [* * *               * * * * * *             * * * * * * *      ] ( 5)
//  6: [* * *           * * * * *             * * * * *           * * *] ( 6)
//  7: [* *           * * * *           * * * * *         * * * * *    ] ( 7)
//  8: [* *         * * * *         * * * *         * * * *         * *] ( 8)
//  9: [* *       * * * *       * * * *         * * *         * * *    ] ( 9)
// 10: [* *       * * *       * * *         * * *       * * *       * *] (10)
// 11: [*       * * *       * * *       * * *       * * *       * * *  ] (11)
// 12: [*       * * *     * * *       * *       * * *     * * *       *] (12)
// 13: [*       * *       * *       * *     * * *     * * *     * * *  ] (13)
// 14: [*     * * *     * *       * *     * *       * *     * * *     *] (14)
// 15: [*     * *     * * *     * *     * *     * *       * *     * *  ] (15)
// 16: [*     * *     * *     * *     * *     * *     * *     * *     *] (16)
// 17: [*     * *     *     * *     * *     * *     * *   * *     * *  ] (17)
// 18: [*     *     * *     * *   * *     * *   * *     * *     *     *] (18)
// 19: [*     *     * *   * *     *     * *   * *     *     * *   * *  ] (19)
// 20: [*   * *     *     *     * *   * *   * *     *     *     * *   *] (20)
// 21: [*   * *   * *   * *   * *   * *     *     *     *     *     *  ] (21)
// 22: [*   * *   * *   *     *     *     *     *     *   * *   * *   *] (22)
// 23: [*   *     *     *   * *   * *   *     *     *   * *   * *   *  ] (23)
// 24: [*   *     *   * *   *     *   * *   *     *   * *   *     *   *] (24)
// 25: [*   *   * *   *     *   *     *   * *   *   * *   *     *   *  ] (25)
// 26: [*   *   * *   *   *     *   *     *   *     *   *   * *   *   *] (26)
// 27: [*   *   *     *   *   *     *   *   * *   *   *   * *   *   *  ] (27)
// 28: [*   *   *   *     *   *   *   * *   *   *   *     *   *   *   *] (28)
// 29: [*   *   *   *   *   * *   *   *   *   *     *   *   *   *   *  ] (29)
// 30: [*   *   *   *   *   *   *   *     *   *   *   *   *   *   *   *] (30)
// 31: [*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  ] (31)
// H.Malvars algorithm: dct by fht
// ldn := base-2 logarithm of the array length
// tmp := (optional) pointer to scratch space
// if a (size-n) srcatch space is supplied (tmp!=0)
// then the slightly faster version of unzip_rev is used

void idcth(double *x, ulong ldn, double *tmp/*=0*/);
// inverse transform wrt. basis: cos(k*(i+0.5)*PI/n) * (k==0?1.0:sqrt(2))
// H.Malvars algorithm: idct by fht
// if a (size-n) srcatch space is supplied (tmp!=0)
// then the slightly faster version of zip_rev is used

void dcth_basis(double *f, ulong n, ulong k);

// ----- SRCFILE=src/dctdst/dctzapata.cc: -----
static void coseno(double *x, ulong ldn);
// Auxiliary routine called by dct_zapata().
// Input:
//  x[k] = \sum_{m=0}^{n-1}{ \prod_{i=0}^{ldn-1}{ 2^{b_i} \cos(b_i 2^i \Theta_m) x(m)} }
//  where n=2^ldn, \Theta_m=\pi (1+4m)/(2n)
//  and  b_i is bit #i of k
// Output:
//  x[k] = \sum_{m=0}^{n-1}{ \cos(\Theta_m) x(m)}

void dcth_zapata(double *x, ulong ldn, double *tmp/*=0*/);
// Transform wrt. basis: cos(k*(i+0.5)*PI/n) * (k==0?1.0:sqrt(2))
// Algorithm as described in F.Arguello, E.L.Zapata:
// "Fast Cosine Transform on the Successive Doubling Method"
// If a (size-n) srcatch space is supplied (tmp!=0)
// then the slightly faster version of unzip_rev() is used.
// Note the unzip_rev() step is not mentioned in the paper!

// ----- SRCFILE=src/dctdst/dct4.cc: -----
void dct4(double *f, ulong ldn);
//  Cosine transform wrt. the basis
//      cos( 2*Pi * 0.25 * (4*k + 1) * i / n )
//    == cos( Pi * (2*k + 0.5) * i / n )
//   where k is the index of the basis
// the basis:
//  0: [* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *] ( 0)
//  1: [* * * * * * *                           * * * * * * * * * * * *] ( 2)
//  2: [* * * *               * * * * * * *               * * * * * * *] ( 4)
//  3: [* * *           * * * * *           * * * * *           * * * *] ( 6)
//  4: [* *         * * * *         * * *         * * * *         * * *] ( 8)
//  5: [* *       * * *       * * *       * * *       * * *       * * *] (10)
//  6: [* *     * * *     * * *       * *       * *       * *       * *] (12)
//  7: [* *     * *     * *       * *     * *     * * *     * *     * *] (14)
//  8: [*     * *     * *     * *     * *     * *     * *     * *     *] (16)
//  9: [*     * *     *     * *   * *     * *   * *     * *   * *     *] (18)
// 10: [*     *     * *   * *   * *   * *   * *     *     *     *     *] (20)
// 11: [*     *   * *   * *   * *   *     *     *     *   * *   * *   *] (22)
// 12: [*   * *   *     *   * *   *     *   *     *   * *   *     *   *] (24)
// 13: [*   * *   *   *     *   *   * *   *   *     *   *   * *   *   *] (26)
// 14: [*   *   * *   *   *   *   * *   *   *   *   * *   *   *   *   *] (28)
// 15: [*   *   *   *   *   * *   *   *   *   *   *   *   *   *   *   *] (30)
// 16: [*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  ] (31)
// 17: [*   *   *   * *   *   *   *   *   *   * *   *   *   *   *   *  ] (29)
// 18: [*   *     *   *   *     *   *   *     *   *   *     *   *   *  ] (27)
// 19: [*   * *   *   * *   *   * *   *   * *   *   * *   *   * *   *  ] (25)
// 20: [*     *   * *   *     *   * *   * *   *     *   * *   *     *  ] (23)
// 21: [*     *     *     *     *     *     *     *     *     *     *  ] (21)
// 22: [*     * *   * *     *     *     * *   * *     *     * *   * *  ] (19)
// 23: [*     * *     * *     *     * *     * *     *     * *     * *  ] (17)
// 24: [* *     * *     * *     * *     * *     * *     * *     * *    ] (15)
// 25: [* *     * *       * *       * *     * * *     * *       * *    ] (13)
// 26: [* *       * *       * * *       * * *     * * *       * * *    ] (11)
// 27: [* *         * * *       * * * *       * * *         * * *      ] ( 9)
// 28: [* * *         * * * *         * * * * *         * * * *        ] ( 7)
// 29: [* * *             * * * * * *             * * * * * *          ] ( 5)
// 30: [* * * * *                   * * * * * * * * *                  ] ( 3)
// 31: [* * * * * * * * * * *                                          ] ( 1)
//  The mean value of all basis functions is nonzero
//  therefore the DC part has to be treated separately

void idct4(double *f, ulong ldn);
// Inverse of dct4()
//  ... which is a transform wrt. the basis
//  cos(  Pi * k * (2*i+0.5) / n )
//   where k is the index of the basis

void dct4_basis(double *f, ulong n, ulong k);

// ----- SRCFILE=src/dctdst/dst.cc: -----
void dst(double *f, ulong ldn, double *tmp/*=0*/);
// basis: sin(k*i*M_PI/n)
// almost self-inverse:  dst(dst(f[])) = 0.5*f[]
// ldn := base-2 logarithm of the array length
// tmp := (optional) pointer to scratch space
// the basis:
//  0: [*                                                              ] ( 1)
//  1: [  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *] ( 2)
//  2: [  * * * * * * * * * * * * * * *                                ] ( 3)
//  3: [  * * * * * * * * * *                       * * * * * * * * * *] ( 4)
//  4: [  * * * * * * *                   * * * * * * *                ] ( 5)
//  5: [  * * * * * *             * * * * * * *             * * * * * *] ( 6)
//  6: [  * * * * *           * * * * *             * * * * *          ] ( 7)
//  7: [  * * * *           * * * *           * * * *           * * * *] ( 8)
//  8: [  * * *           * * *           * * *           * * *        ] ( 9)
//  9: [  * * *         * * *         * * *         * * *         * * *] (10)
// 10: [  * * *       * * *       * * *         * * *       * * *      ] (11)
// 11: [  * *       * * *       * * *       * * *       * * *       * *] (12)
// 12: [  * *       * *       * * *       * *       * *       * * *    ] (13)
// 13: [  * *     * * *     * * *     * * *     * * *     * * *     * *] (14)
// 14: [  * *     * *       * *     * *       * *     * * *     * *    ] (15)
// 15: [  * *     * *     * *     * *       * *     * *     * *     * *] (16)
// 16: [  *       *       *       *       *       *       *       *    ] (17)
// 17: [  *     * *     * *     * *     *     * *     * *     * *     *] (18)
// 18: [  *     * *     *     * *     *     * *     * *   * *     * *  ] (19)
// 19: [  *     * *   * *     *     * *   * *     *     * *   * *     *] (20)
// 20: [  *     *     *     * *   * *     *     *     *     * *   * *  ] (21)
// 21: [  *     *     *     *     *     *     *     *     *     *     *] (22)
// 22: [  *   * *   * *   * *   * *   *     *     *     *     *     *  ] (23)
// 23: [  *   * *   *     *     *   * *   * *   *     *     *   * *   *] (24)
// 24: [  *   *     *     *   *     *     *   *     *     *   *     *  ] (25)
// 25: [  *   *     *   *     *   * *   *   * *   *     *   *     *   *] (26)
// 26: [  *   *   * *   *   * *   *   *     *   *     *   *     *   *  ] (27)
// 27: [  *   *   *     *   *   * *   *   *   * *   *   *     *   *   *] (28)
// 28: [  *   *   *   *     *   *   *     *   *   *   *     *   *   *  ] (29)
// 29: [  *   *   *   *   *     *   *   *   *   *     *   *   *   *   *] (30)
// 30: [  *   *   *   *   *   *   *   *     *   *   *   *   *   *   *  ] (31)
// 31: [  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *] (32)

void dst_basis(double *f, ulong n, ulong k);

// ----- SRCFILE=src/dctdst/dsth.cc: -----
void dsth(double *x, ulong ldn, double *tmp/*=0*/);
// Compute (discrete) sine transform (DST) with
//  basis sin((k+1)*(i+0.5)*M_PI/n) * sqrt(2)
// ldn := base-2 logarithm of the array length
// tmp := (optional) pointer to scratch space
// the basis:
//  0: [* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *] ( 0)
//  1: [* * * * * * * * * * * * * * * *                                ] ( 1)
//  2: [* * * * * * * * * * *                     * * * * * * * * * * *] ( 2)
//  3: [* * * * * * * *                 * * * * * * * *                ] ( 3)
//  4: [* * * * * *               * * * * * *               * * * * * *] ( 4)
//  5: [* * * * *             * * * * *           * * * * * *          ] ( 5)
//  6: [* * * * *         * * * * *         * * * * *         * * * * *] ( 6)
//  7: [* * * *         * * * *         * * * *         * * * *        ] ( 7)
//  8: [* * * *       * * * *       * * * *       * * * *       * * * *] ( 8)
//  9: [* * *       * * * *       * * *       * * *         * * *      ] ( 9)
// 10: [* * *       * * *       * * *     * * *       * * *       * * *] (10)
// 11: [* * *     * * *       * *       * * *     * * *       * *      ] (11)
// 12: [* *       * *       * *       * *       * *       * *       * *] (12)
// 13: [* *       * *     * *       * *     * * *     * *     * * *    ] (13)
// 14: [* *     * *       * *     * *     * *     * *       * *     * *] (14)
// 15: [* *     * *     * *     * *     * *     * *     * *     * *    ] (15)
// 16: [* *     * *     *     * *     * *     * *     *     * *     * *] (16)
// 17: [* *     *     * *     *     * *     * *   * *     * *   * *    ] (17)
// 18: [* *   * *     *     * *   * *     * *   * *     *     * *   * *] (18)
// 19: [* *   * *   * *     *     *     * *   * *   * *     *     *    ] (19)
// 20: [* *   * *   * *   * *   * *   * *   * *   * *   * *   * *   * *] (20)
// 21: [*     *     *     *     *     *   * *   * *   * *   * *   * *  ] (21)
// 22: [*     *     *   * *   * *   *     *   * *   * *   *     *     *] (22)
// 23: [*     *   * *   *     *   * *   *     *   * *   *     *   * *  ] (23)
// 24: [*     *   *     *   * *   *   * *   *   * *   *     *   *     *] (24)
// 25: [*   * *   *   * *   *   * *   *   *     *   *     *   *     *  ] (25)
// 26: [*   * *   *   *   * *   *   *     *   *   * *   *   *   * *   *] (26)
// 27: [*   *     *   *   *   * *   *   *   *     *   *   *   * *   *  ] (27)
// 28: [*   *   * *   *   *   *   *   * *   *   *   *   *   * *   *   *] (28)
// 29: [*   *   *   *     *   *   *   *   *   *   *   * *   *   *   *  ] (29)
// 30: [*   *   *   *   *   *   *   *     *   *   *   *   *   *   *   *] (30)
// 31: [*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  ] (31)

void idsth(double *x, ulong ldn, double *tmp/*=0*/);
// Inverse of dsth()
// ldn := base-2 logarithm of the array length
// tmp := (optional) pointer to scratch space

void dsth_basis(double *f, ulong n, ulong k);

