// -*- C++ -*-
// automatically generated by autodoc

// ========== HEADER FILE src/walsh/and-convolution.h: ==========

inline void slow_and_convolution(const Type *f, const Type *g, ulong ldn, Type *h);
// Compute the AND-convolution h[] of f[] and g[]:
//  h[k] = sum(i & j == k,  f[i]*g[j])
// Result written to h[].

inline void and_convolution(Type * restrict f, Type * restrict g, ulong ldn);
// Compute the AND-convolution h[] of f[] and g[]:
//  h[k] = sum(i & j == k,  f[i]*g[j])
// f[] and g[] must not overlap.
// Result written to g[].

inline void and_auto_convolution(Type *f, ulong ldn);
// Compute the self- AND-convolution h[] of f[]:
//  h[k] = sum(i & j == k,  f[i]*f[j])
// Result written to f[].

// ========== HEADER FILE src/walsh/arithtransform.h: ==========

void arith_transform_plus(Type *f, ulong ldn);
// Arithmetic transform (positive sign).
// Radix-2 decimation In Frequency (DIF) algorithm.
// Inverse of arith_transform_minus().

void arith_transform_minus(Type *f, ulong ldn);
// Arithmetic transform (negative sign).
// Radix-2 decimation In Frequency (DIF) algorithm.
// Inverse of arith_transform_plus().

void rev_arith_transform_plus(Type *f, ulong ldn);
// Reversed arithmetic transform (positive sign).
// Radix-2 decimation In Frequency (DIF) algorithm.
// Inverse of rev_arith_transform_minus().
// Same as:
// { n=1UL<<ldn; reverse(f,n); arith_transform_plus(f,ldn); reverse(f,n); }

void rev_arith_transform_minus(Type *f, ulong ldn);
// Reversed arithmetic transform (negative sign).
// Radix-2 decimation In Frequency (DIF) algorithm.
// Inverse of rev_arith_transform_plus().
// Same as:
// { n=1UL<<ldn; reverse(f,n); arith_transform_minus(f,ldn); reverse(f,n); }

// ========== HEADER FILE src/walsh/bitcount-weight.h: ==========

void bit_count_weight(Type *f, ulong ldn, Type w);
// Multiply f[i] by w**bitcount(i).

void rev_bit_count_weight(Type *f, ulong ldn, Type w);
// Multiply f[i] by w**bitcount(n-1-i).

// ========== HEADER FILE src/walsh/dyadiccnvl.h: ==========

void dyadic_convolution(Type * restrict f, Type * restrict g, ulong ldn);
// Dyadic convolution (XOR-convolution):  h[] of f[] and g[]:
//   h[k] = sum( i XOR j == k,  f[i]*g[k] )
// Result is written to g[].
// ldn := base-2 logarithm of the array length
//.
// Convolution diagram:
//   +--   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
//   |
//   0:    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
//   1:    1  0  3  2  5  4  7  6  9  8 11 10 13 12 15 14
//   2:    2  3  0  1  6  7  4  5 10 11  8  9 14 15 12 13
//   3:    3  2  1  0  7  6  5  4 11 10  9  8 15 14 13 12
//   4:    4  5  6  7  0  1  2  3 12 13 14 15  8  9 10 11
//   5:    5  4  7  6  1  0  3  2 13 12 15 14  9  8 11 10
//   6:    6  7  4  5  2  3  0  1 14 15 12 13 10 11  8  9
//   7:    7  6  5  4  3  2  1  0 15 14 13 12 11 10  9  8
//   8:    8  9 10 11 12 13 14 15  0  1  2  3  4  5  6  7
//   9:    9  8 11 10 13 12 15 14  1  0  3  2  5  4  7  6
//  10:   10 11  8  9 14 15 12 13  2  3  0  1  6  7  4  5
//  11:   11 10  9  8 15 14 13 12  3  2  1  0  7  6  5  4
//  12:   12 13 14 15  8  9 10 11  4  5  6  7  0  1  2  3
//  13:   13 12 15 14  9  8 11 10  5  4  7  6  1  0  3  2
//  14:   14 15 12 13 10 11  8  9  6  7  4  5  2  3  0  1
//  15:   15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0

void dyadic_auto_convolution(Type *f, ulong ldn);
// Dyadic self-convolution.
// ldn := base-2 logarithm of the array length

// ========== HEADER FILE src/walsh/fib-walsh.h: ==========

inline void fibonacci_walsh(double *a, ulong f0, ulong f1);
// In-place Fibonacci-Walsh transform of a[0,...,f0-1].
// f0 must be a Fibonacci number, f1 the next smaller Fibonacci number.

inline void fibonacci_walsh_nn(double *a, ulong f0, ulong f1);
// In-place Fibonacci-Walsh transform of a[0,...,f0-1].
// Non-normalized version.
// f0 must be a Fibonacci number, f1 the next smaller Fibonacci number.

// ========== HEADER FILE src/walsh/grsnegate.h: ==========

void grs_negate(Type *f, ulong n);
// Negate elements at indices where the Golay-Rudin-Shapiro is negative.

// ========== HEADER FILE src/walsh/max-convolution.h: ==========

inline void slow_max_convolution(const Type *f, const Type *g, ulong n, Type *h);
// Compute the MAX-convolution h[] of f[] and g[]:
//  h[k] = sum( max(i,j) == k,  f[i]*g[j])
// Result written to h[].

inline void max_convolution(const Type *f, const Type *g, ulong n, Type *h);
// Compute the MAX-convolution h[] of f[] and g[]:
//  h[k] = sum( max(i,j) == k,  f[i]*g[j])
// Result written to h[].

// ========== HEADER FILE src/walsh/mers-walsh.h: ==========

inline void mersenne_walsh(double *a, ulong f0);
// In-place Mersenne-Walsh transform of a[0,...,f0-1].
// f0 must be a Mersenne number.
// Self-inverse.

inline void mersenne_walsh_nn(double *a, ulong f0);
// In-place Mersenne-Walsh transform of a[0,...,f0-1].
// Non-normalized version.
// f0 must be a Mersenne number.

// ========== HEADER FILE src/walsh/or-convolution.h: ==========

inline void slow_or_convolution(const Type *f, const Type *g, ulong ldn, Type *h);
// Compute the OR-convolution h[] of f[] and g[]:
//  h[k] = sum(i | j == k,  f[i]*g[j])
// Result written to h[].

inline void slow_or_convolution(const Type *f, Type *g, ulong ldn);
// Result written to g[].

inline void or_convolution(Type * restrict f, Type * restrict g, ulong ldn);
// Compute the OR-convolution h[] of f[] and g[]:
//  h[k] = sum(i | j == k,  f[i]*g[j])
// f[] and g[] must not overlap.
// Result written to g[].

inline void or_auto_convolution(Type *f, ulong ldn);
// Compute the self- OR-convolution h[] of f[]:
//  h[k] = sum(i | j == k,  f[i]*f[j])
// Result written to f[].

// ========== HEADER FILE src/walsh/reedmuller.h: ==========

void word_reed_muller_dif2(Type *f, ulong ldn);
// Reed-Muller Transform.
// Radix-2 decimation in frequency (DIF) algorithm.
// Self-inverse.
// Type must have the XOR operator.
//.
// Transform wrt. to the basis: (sequency at end of lines, '*':=1, ' ':=-1)
//  0: [* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *] ( 0)
//  1: [  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *] (32)
//  2: [    * *     * *     * *     * *     * *     * *     * *     * *] (16)
//  3: [      *       *       *       *       *       *       *       *] (16)
//  4: [        * * * *         * * * *         * * * *         * * * *] ( 8)
//  5: [          *   *           *   *           *   *           *   *] (16)
//  6: [            * *             * *             * *             * *] ( 8)
//  7: [              *               *               *               *] ( 8)
//  8: [                * * * * * * * *                 * * * * * * * *] ( 4)
//  9: [                  *   *   *   *                   *   *   *   *] (16)
// 10: [                    * *     * *                     * *     * *] ( 8)
// 11: [                      *       *                       *       *] ( 8)
// 12: [                        * * * *                         * * * *] ( 4)
// 13: [                          *   *                           *   *] ( 8)
// 14: [                            * *                             * *] ( 4)
// 15: [                              *                               *] ( 4)
// 16: [                                * * * * * * * * * * * * * * * *] ( 2)
// 17: [                                  *   *   *   *   *   *   *   *] (16)
// 18: [                                    * *     * *     * *     * *] ( 8)
// 19: [                                      *       *       *       *] ( 8)
// 20: [                                        * * * *         * * * *] ( 4)
// 21: [                                          *   *           *   *] ( 8)
// 22: [                                            * *             * *] ( 4)
// 23: [                                              *               *] ( 4)
// 24: [                                                * * * * * * * *] ( 2)
// 25: [                                                  *   *   *   *] ( 8)
// 26: [                                                    * *     * *] ( 4)
// 27: [                                                      *       *] ( 4)
// 28: [                                                        * * * *] ( 2)
// 29: [                                                          *   *] ( 4)
// 30: [                                                            * *] ( 2)
// 31: [                                                              *] ( 2)
//

void word_reed_muller_dit2(Type *f, ulong ldn);
// Reed-Muller Transform.
// Radix-2 decimation in time (DIT) algorithm.
// Self-inverse.
// Type must have the XOR operator.

inline void word_reed_muller(Type *f, ulong ldn);

inline void reed_muller_basis(Type *f, ulong n, ulong k);
// Basis function of the Reed-Muller transform

inline void bit_reed_muller(Type *f, ulong ldn);

// ========== HEADER FILE src/walsh/shortwalshwakdif.h: ==========

// walsh_wak_dif() for fixed array sizes
static inline void short_walsh_wak_dif_2(Type *f);

static inline void short_walsh_wak_dif_2(Type *f, ulong s);

static inline void short_walsh_wak_dif_4(Type *f);

static inline void short_walsh_wak_dif_4(Type *f, ulong s);

inline void short_walsh_wak_dif_8(Type *f);

inline void short_walsh_wak_dif_8(Type *f, ulong s);

inline void short_walsh_wak_dif_16(Type *f);

inline void short_walsh_wak_dif_16(Type *f, ulong s);

// ========== HEADER FILE src/walsh/shortwalshwakdit.h: ==========

// walsh_wak_dit() for fixed array sizes
static inline void short_walsh_wak_dit_2(Type *f);

static inline void short_walsh_wak_dit_2(Type *f, ulong s);

static inline void short_walsh_wak_dit_4(Type *f);

static inline void short_walsh_wak_dit_4(Type *f, ulong s);

inline void short_walsh_wak_dit_8(Type *f);

inline void short_walsh_wak_dit_8(Type *f, ulong s);

inline void short_walsh_wak_dit_16(Type *f);

inline void short_walsh_wak_dit_16(Type *f, ulong s);

// ========== HEADER FILE src/walsh/slant.h: ==========

// ----- SRCFILE=src/walsh/slant.cc: -----
void slant(double *f, ulong ldn);
// Slant transform.

void inverse_slant(double *f, ulong ldn);
// Inverse of slant()

void slant_seq(double *f, ulong ldn);
// Sequency-ordered slant transform.

void inverse_slant_seq(double *f, ulong ldn);
// Inverse of slant_seq().

// ========== HEADER FILE src/walsh/square-wave-transform.h: ==========

// Square wave transform
void square_wave_basis(Type *f, ulong n, ulong k);
// Compute the k-th basis vector for the square wave transform.
// The vectors are not mutually orthogonal.

void swt_normalize(Type *f, ulong n);
// Normalization for the square wave transform.

void square_wave_transform(Type *f, ulong ldn, bool nq=true);
// Square wave transform.
// The transform of a delta-pulse has norm 1 (if nq==true).
// Algorithm is O(n) where n is the length of the sequence f[].
//
// This transform (with nq==false) is multiplication
// with the following matrix ('+':=+1, '-':=-1):
// (i.e., the rows are the basis functions)
//   0: [ + - - - - - - - - - - - - - - - - + + + + + + + + + + + + + + + ]
//   1: [ + + - - - - - - - - - - - - - - - - + + + + + + + + + + + + + + ]
//   2: [ + + + - - - - - - - - - - - - - - - - + + + + + + + + + + + + + ]
//   3: [ + + + + - - - - - - - - - - - - - - - - + + + + + + + + + + + + ]
//   4: [ + + + + + - - - - - - - - - - - - - - - - + + + + + + + + + + + ]
//   5: [ + + + + + + - - - - - - - - - - - - - - - - + + + + + + + + + + ]
//   6: [ + + + + + + + - - - - - - - - - - - - - - - - + + + + + + + + + ]
//   7: [ + + + + + + + + - - - - - - - - - - - - - - - - + + + + + + + + ]
//   8: [ + + + + + + + + + - - - - - - - - - - - - - - - - + + + + + + + ]
//   9: [ + + + + + + + + + + - - - - - - - - - - - - - - - - + + + + + + ]
//  10: [ + + + + + + + + + + + - - - - - - - - - - - - - - - - + + + + + ]
//  11: [ + + + + + + + + + + + + - - - - - - - - - - - - - - - - + + + + ]
//  12: [ + + + + + + + + + + + + + - - - - - - - - - - - - - - - - + + + ]
//  13: [ + + + + + + + + + + + + + + - - - - - - - - - - - - - - - - + + ]
//  14: [ + + + + + + + + + + + + + + + - - - - - - - - - - - - - - - - + ]
//  15: [ + + + + + + + + + + + + + + + + - - - - - - - - - - - - - - - - ]
//  16: [ + - - - - - - - - + + + + + + + + - - - - - - - - + + + + + + + ]
//  17: [ + + - - - - - - - - + + + + + + + + - - - - - - - - + + + + + + ]
//  18: [ + + + - - - - - - - - + + + + + + + + - - - - - - - - + + + + + ]
//  19: [ + + + + - - - - - - - - + + + + + + + + - - - - - - - - + + + + ]
//  20: [ + + + + + - - - - - - - - + + + + + + + + - - - - - - - - + + + ]
//  21: [ + + + + + + - - - - - - - - + + + + + + + + - - - - - - - - + + ]
//  22: [ + + + + + + + - - - - - - - - + + + + + + + + - - - - - - - - + ]
//  23: [ + + + + + + + + - - - - - - - - + + + + + + + + - - - - - - - - ]
//  24: [ + - - - - + + + + - - - - + + + + - - - - + + + + - - - - + + + ]
//  25: [ + + - - - - + + + + - - - - + + + + - - - - + + + + - - - - + + ]
//  26: [ + + + - - - - + + + + - - - - + + + + - - - - + + + + - - - - + ]
//  27: [ + + + + - - - - + + + + - - - - + + + + - - - - + + + + - - - - ]
//  28: [ + - - + + - - + + - - + + - - + + - - + + - - + + - - + + - - + ]
//  29: [ + + - - + + - - + + - - + + - - + + - - + + - - + + - - + + - - ]
//  30: [ + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - + - ]
//  31: [ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + ]
// If nq==true then norm of all row vectors is sqrt(n).
// If nq==true then the norm of the row vectors is
//  sqrt(1) for the last 4,  sqrt(2) for the prior 4 (again 4),
//  sqrt(4) for the prior 8,  sqrt(8) for the prior 16,
//  sqrt(16) for the prior 32,  etc.

void inverse_square_wave_transform(Type *f, ulong ldn, bool nq=true);
// Inverse of the square wave transform (if nq==true in both transforms).
// Algorithm is O(n) where n is the length of the sequence f[].
//
// This transform (with nq==false) is multiplication
// with the following matrix ('+':=+1, '-':=-1, ' ':=0):
//
//   0: [ +                             + +             + +     + + + + + ]
//   1: [ - +                             - +             - +     - + - + ]
//   2: [   - +                             - +             - +   - - + + ]
//   3: [     - +                             - +             - + + - - + ]
//   4: [       - +                             - +       -     - + + + + ]
//   5: [         - +                             - +     + -     - + - + ]
//   6: [           - +                             - +     + -   - - + + ]
//   7: [             - +                             - +     + - + - - + ]
//   8: [               - +               -             - +     + + + + + ]
//   9: [                 - +             + -             - +     - + - + ]
//  10: [                   - +             + -             - +   - - + + ]
//  11: [                     - +             + -             - + + - - + ]
//  12: [                       - +             + -       -     - + + + + ]
//  13: [                         - +             + -     + -     - + - + ]
//  14: [                           - +             + -     + -   - - + + ]
//  15: [                             - +             + -     + - + - - + ]
//  16: [ -                             - +             + +     + + + + + ]
//  17: [ + -                             - +             - +     - + - + ]
//  18: [   + -                             - +             - +   - - + + ]
//  19: [     + -                             - +             - + + - - + ]
//  20: [       + -                             - +       -     - + + + + ]
//  21: [         + -                             - +     + -     - + - + ]
//  22: [           + -                             - +     + -   - - + + ]
//  23: [             + -                             - +     + - + - - + ]
//  24: [               + -               -             - +     + + + + + ]
//  25: [                 + -             + -             - +     - + - + ]
//  26: [                   + -             + -             - +   - - + + ]
//  27: [                     + -             + -             - + + - - + ]
//  28: [                       + -             + -       -     - + + + + ]
//  29: [                         + -             + -     + -     - + - + ]
//  30: [                           + -             + -     + -   - - + + ]
//  31: [                             + -             + -     + - + - - + ]
// If nq==false then the norm all row vectors is sqrt(2*n).  (?? to check)
// If nq==true then the norm all row vectors is 1.
//

// ========== HEADER FILE src/walsh/subset-convolution.h: ==========

inline void slow_subset_convolution(const Type *f, const Type *g, ulong ldn, Type *h);
// Compute the subset convolution h[] of f[] and g[]:
//   h[k] = sum( j subset k,  f[j]*g[k-j] )
// Could iterate over subsets to make faster.

inline void slow_subset_convolution(const Type *f, Type *g, ulong ldn);
// Result written to g[].

inline void slow_subset_auto_convolution(const Type *f, ulong ldn, Type *h);
// Compute the subset auto- convolution of f[]:
//   h[k] = sum( j subset k,  f[j]*f[k-j] )

inline void slow_subset_auto_convolution(const Type *f, Type *g, ulong ldn);
// Result written to g[].

inline void subset_convolution(Type *f, Type *g, ulong ldn);
// Compute the subset convolution h[] of f[] and g[]:
//   h[k] = sum( j subset k,  f[j]*g[k-j] )
// Type must allow conversion to and from type Complex.
// Result written to g[].

inline void subset_auto_convolution(Type *f, ulong ldn);
// Compute the subset auto- convolution h[] of f[]:
//   h[k] = sum( j subset k,  f[j]*f[k-j] )
// Type must allow conversion to and from type Complex
// Result written to f[].

// ========== HEADER FILE src/walsh/walsh-basis.h: ==========

void walsh_wak_basis(Type *f, ulong n, ulong k);
// Compute the k-th basis function for
// the Walsh-Kronecker transform (wak-functions).

void walsh_pal_basis(Type *f, ulong n, ulong k);
// Compute the k-th basis function for
// the Walsh-Paley transform (pal-functions).

void walsh_wal_basis(Type *f, ulong n, ulong k);
// Compute the k-th basis function for
// the Walsh-Kaczmarz transform (wal-functions).

void walsh_wal_rev_basis(Type *f, ulong n, ulong k);
// Compute the k-th basis function for the transform walsh_wal_rev()

void walsh_q1_basis(Type *f, ulong n, ulong k);
// Compute the k-th basis function for the transform walsh_q1()

void walsh_q2_basis(Type *f, ulong n, ulong k);
// Compute the k-th basis function for the transform walsh_q2()

// ========== HEADER FILE src/walsh/walsheigen.h: ==========

// eigenvectors for certain Walsh transforms
// ----- SRCFILE=src/walsh/walsheigen.cc: -----
void walsh_wak_eigen(double *v, ulong ldn, ulong k);
// Eigenvectors of the Walsh transform (walsh_wak).
// Eigenvalues are +1 if k<n/2, else -1

void walsh_wal_eigen(double *v, ulong ldn, ulong k);
// Eigenvectors of the Walsh transform (walsh_wal).
// Eigenvalues are +1 if k<n/2, else -1

void walsh_pal_eigen(double *v, ulong ldn, ulong k);
// Eigenvectors of the Walsh transform (walsh_pal).
// Eigenvalues are +1 if k<n/2, else -1

// ========== HEADER FILE src/walsh/walshgray.h: ==========

void walsh_gray(Type *f, ulong ldn);
// Gray variant of the Walsh transform.
// Radix-2 decimation in frequency (DIF) algorithm
//.
// The basis (sequency at end of lines, '*':=1, ' ':=-1):
//  0: [* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *] ( 0)
//  1: [*     * *     * *     * *     * *     * *     * *     * *     *] (16)
//  2: [* *         * * * *         * * * *         * * * *         * *] ( 8)
//  3: [  *   * *   *     *   * *   *     *   * *   *     *   * *   *  ] (24)
//  4: [* * * *                 * * * * * * * *                 * * * *] ( 4)
//  5: [*     *   * *     * *   *     * *     *   * *     * *   *     *] (20)
//  6: [    * *     * * * *     * *         * *     * * * *     * *    ] (12)
//  7: [*   *   *   *     *   *   *   * *   *   *   *     *   *   *   *] (28)
//  8: [* * * * * * * *                                 * * * * * * * *] ( 2)
//  9: [*     * *     *   * *     * *     * *     * *   *     * *     *] (18)
// 10: [* *         * *     * * * *         * * * *     * *         * *] (10)
// 11: [  *   * *   *   *   *     *   * *   *     *   *   *   * *   *  ] (26)
// 12: [        * * * *         * * * * * * * *         * * * *        ] ( 6)
// 13: [  * *   *     *   * *   *     * *     *   * *   *     *   * *  ] (22)
// 14: [* *     * *     * *     * *         * *     * *     * *     * *] (14)
// 15: [  *   *   *   *   *   *   *   * *   *   *   *   *   *   *   *  ] (30)
// 16: [* * * * * * * * * * * * * * * *                                ] ( 1)
// 17: [*     * *     * *     * *     *   * *     * *     * *     * *  ] (17)
// 18: [* *         * * * *         * *     * * * *         * * * *    ] ( 9)
// 19: [  *   * *   *     *   * *   *   *   *     *   * *   *     *   *] (25)
// 20: [* * * *                 * * * *         * * * * * * * *        ] ( 5)
// 21: [*     *   * *     * *   *     *   * *   *     * *     *   * *  ] (21)
// 22: [    * *     * * * *     * *     * *     * *         * *     * *] (13)
// 23: [*   *   *   *     *   *   *   *   *   *   *   * *   *   *   *  ] (29)
// 24: [                * * * * * * * *                 * * * * * * * *] ( 3)
// 25: [  * *     * *   *     * *     *   * *     * *   *     * *     *] (19)
// 26: [    * * * *     * *         * *     * * * *     * *         * *] (11)
// 27: [*   *     *   *   *   * *   *   *   *     *   *   *   * *   *  ] (27)
// 28: [* * * *         * * * *         * * * *         * * * *        ] ( 7)
// 29: [*     *   * *   *     *   * *   *     *   * *   *     *   * *  ] (23)
// 30: [    * *     * *     * *     * *     * *     * *     * *     * *] (15)
// 31: [*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  ] (31)
//
//
// Fast on some machines, due to cache fiendly memory access.
//
// walsh_wak() =^=
//   inverse_gray_permute(f, n);
//   walsh_gray(f, ldn);
//   grs_negate(f, n);
//
// walsh_wal() =^=
//   walsh_gray(f, ldn);
//   grs_negate(f, n);
//   revbin_permute(f, n);
//

void inverse_walsh_gray(Type *f, ulong ldn);
// Inverse of walsh_gray().
// Radix-2 decimation in time (DIT) algorithm.
//.
// The basis (sequency at end of lines, '*':=1, ' ':=-1):
//  0: [* * *   * *   * * * *       *   * * *   * *   *       * * *   *] (16)
//  1: [*   * * *       *   * *   * * * *   * * *         *     *      ] (15)
//  2: [*       *   * * *         *     *       *   * *   * * * *   * *] (16)
//  3: [* *   * * * *   * *   *       * * *   * * * *       *   * * *  ] (15)
//  4: [* *   *       * * *   * * * *   * *   *       *     *         *] (16)
//  5: [*         *     *       *   * * *         *       * * *   *    ] (15)
//  6: [*   * *   * * * *   * * *       *   * *   * * *   *       * * *] (16)
//  7: [* * *       *   * * *   * *   * * * *       *         *     *  ] (15)
//  8: [* * *       *         *     *   * * *       *   * * *   * *   *] (16)
//  9: [*   * *   * * *   *       * * * *   * *   * * * *   * * *      ] (15)
// 10: [*         *       * * *   *     *         *     *       *   * *] (16)
// 11: [* *   *       *     *         * * *   *       * * *   * * * *  ] (15)
// 12: [* *   * * * *       *   * * *   * *   * * * *   * *   *       *] (16)
// 13: [*       *   * *   * * * *   * * *       *   * * *         *    ] (15)
// 14: [*   * * *         *     *       *   * * *       *   * *   * * *] (16)
// 15: [* * *   * *   *       * * *   * * * *   * *   * * * *       *  ] (15)
// 16: [* * *   * *   *       * * *   *       *     *         * * *   *] (16)
// 17: [*   * * *         *     *         *       * * *   *     *      ] (15)
// 18: [*       *   * *   * * * *   * *   * * *   *       * * * *   * *] (16)
// 19: [* *   * * * *       *   * * *       *         *     *   * * *  ] (15)
// 20: [* *   *       *     *         *     *   * * *       *         *] (16)
// 21: [*         *       * * *   *       * * * *   * *   * * *   *    ] (15)
// 22: [*   * *   * * *   *       * * *   *     *         *       * * *] (16)
// 23: [* * *       *         *     *         * * *   *       *     *  ] (15)
// 24: [* * *       *   * * *   * *   *       * * *   * * * *   * *   *] (16)
// 25: [*   * *   * * * *   * * *         *     *       *   * * *      ] (15)
// 26: [*         *     *       *   * *   * * * *   * * *       *   * *] (16)
// 27: [* *   *       * * *   * * * *       *   * * *   * *   * * * *  ] (15)
// 28: [* *   * * * *   * *   *       *     *         * * *   *       *] (16)
// 29: [*       *   * * *         *       * * *   *     *         *    ] (15)
// 30: [*   * * *       *   * *   * * *   *       * * * *   * *   * * *] (16)
// 31: [* * *   * *   * * * *       *         *     *   * * *       *  ] (15)

// ========== HEADER FILE src/walsh/walshpal.h: ==========

inline void walsh_pal(Type *f, ulong ldn);
// Walsh transform wrt. to Walsh-Paley basis (pal-functions).
// Self-inverse.
//.
// The basis (sequency at end of lines, '*':=1, ' ':=-1):
//  0: [* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *] ( 0)
//  1: [* * * * * * * * * * * * * * * *                                ] ( 1)
//  2: [* * * * * * * *                 * * * * * * * *                ] ( 3)
//  3: [* * * * * * * *                                 * * * * * * * *] ( 2)
//  4: [* * * *         * * * *         * * * *         * * * *        ] ( 7)
//  5: [* * * *         * * * *                 * * * *         * * * *] ( 6)
//  6: [* * * *                 * * * * * * * *                 * * * *] ( 4)
//  7: [* * * *                 * * * *         * * * * * * * *        ] ( 5)
//  8: [* *     * *     * *     * *     * *     * *     * *     * *    ] (15)
//  9: [* *     * *     * *     * *         * *     * *     * *     * *] (14)
// 10: [* *     * *         * *     * * * *     * *         * *     * *] (12)
// 11: [* *     * *         * *     * *     * *     * * * *     * *    ] (13)
// 12: [* *         * * * *         * * * *         * * * *         * *] ( 8)
// 13: [* *         * * * *         * *     * * * *         * * * *    ] ( 9)
// 14: [* *         * *     * * * *     * *         * *     * * * *    ] (11)
// 15: [* *         * *     * * * *         * * * *     * *         * *] (10)
// 16: [*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  ] (31)
// 17: [*   *   *   *   *   *   *   *     *   *   *   *   *   *   *   *] (30)
// 18: [*   *   *   *     *   *   *   * *   *   *   *     *   *   *   *] (28)
// 19: [*   *   *   *     *   *   *   *   *   *   *   * *   *   *   *  ] (29)
// 20: [*   *     *   * *   *     *   * *   *     *   * *   *     *   *] (24)
// 21: [*   *     *   * *   *     *   *   *   * *   *     *   * *   *  ] (25)
// 22: [*   *     *   *   *   * *   *   *   *     *   *   *   * *   *  ] (27)
// 23: [*   *     *   *   *   * *   *     *   * *   *   *   *     *   *] (26)
// 24: [*     * *     * *     * *     * *     * *     * *     * *     *] (16)
// 25: [*     * *     * *     * *     *   * *     * *     * *     * *  ] (17)
// 26: [*     * *     *   * *     * *   *     * *     *   * *     * *  ] (19)
// 27: [*     * *     *   * *     * *     * *     * *   *     * *     *] (18)
// 28: [*     *   * *   *     *   * *   *     *   * *   *     *   * *  ] (23)
// 29: [*     *   * *   *     *   * *     * *   *     *   * *   *     *] (22)
// 30: [*     *   * *     * *   *     * *     *   * *     * *   *     *] (20)
// 31: [*     *   * *     * *   *     *   * *   *     * *     *   * *  ] (21)

// ========== HEADER FILE src/walsh/walshq.h: ==========

void walsh_q1(Type *f, ulong ldn);
// Walsh transform with sequencies of basis functions == n/2 or n/2-1
// Self-inverse.
//.
// the basis (sequency at end of lines, '*':=1, ' ':=-1)
//    0: [ * * *   * *   * * * *       *   * * *   * *   *       * * *   * ] (16)
//    1: [ * * *   * *   * * * *       *         *     *   * * *       *   ] (15)
//    2: [ * * *   * *   *       * * *   *       *     *         * * *   * ] (16)
//    3: [       *     *   * * *       *         *     *         * * *   * ] (15)
//    4: [ * * *       *         *     *   * * *       *   * * *   * *   * ] (16)
//    5: [ * * *       *         *     *         * * *   *       *     *   ] (15)
//    6: [       * * *   *       *     *   * * *       *         *     *   ] (16)
//    7: [ * * *       *   * * *   * *   * * * *       *         *     *   ] (15)
//    8: [ * *   *       * * *   * * * *   * *   *       *     *         * ] (16)
//    9: [ * *   *       * * *   * * * *       *   * * *   * *   * * * *   ] (15)
//   10: [ * *   *       *     *         *     *   * * *       *         * ] (16)
//   11: [     *   * * *   * *   * * * *       *   * * *       *         * ] (15)
//   12: [     *         * * *   *       *     *         *     *   * * *   ] (16)
//   13: [     *         * * *   *       * * *   * * * *   * *   *       * ] (15)
//   14: [ * *   * * * *   * *   *       *     *         * * *   *       * ] (16)
//   15: [     *         *     *   * * *       *         * * *   *       * ] (15)
//   16: [ *       *   * * *         *     *       *   * *   * * * *   * * ] (16)
//   17: [ *       *   * * *         *       * * *   *     *         *     ] (15)
//   18: [ *       *   * *   * * * *   * *   * * *   *       * * * *   * * ] (16)
//   19: [   * * *   *     *         *       * * *   *       * * * *   * * ] (15)
//   20: [ *         *       * * *   *     *         *     *       *   * * ] (16)
//   21: [ *         *       * * *   *       * * * *   * *   * * *   *     ] (15)
//   22: [   * * * *   * *   * * *   *     *         *       * * *   *     ] (16)
//   23: [ *         *     *       *   * * *         *       * * *   *     ] (15)
//   24: [   *     *         *       * * *   *     *       *   * * *       ] (16)
//   25: [   *     *         *       * * * *   * *   * * *   *       * * * ] (15)
//   26: [   *     *       *   * * *       *   * *   * * * *   * * *       ] (16)
//   27: [ *   * *   * * *   *       * * * *   * *   * * * *   * * *       ] (15)
//   28: [ *   * * *         *     *       *   * * *       *   * *   * * * ] (16)
//   29: [ *   * * *         *     *         *       * * *   *     *       ] (15)
//   30: [   *       * * *   *     *       *   * * *         *     *       ] (16)
//   31: [ *   * * *       *   * *   * * * *   * * *         *     *       ] (15)
//

void walsh_q2(Type *f, ulong ldn);
// Walsh transform with sequencies of basis functions == n/2 or n/2-1
// Self-inverse.
//.
// The basis (sequency at end of lines, '*':=1, ' ':=-1):
//    0: [ * * *   * *   * * * *       *   * * *   * *   *       * * *   * ] (16)
//    1: [ * * *   * *   *       * * *   *       *     *         * * *   * ] (16)
//    2: [ * * *       *         *     *   * * *       *   * * *   * *   * ] (16)
//    3: [       * * *   *       *     *   * * *       *         *     *   ] (16)
//    4: [ * *   *       * * *   * * * *   * *   *       *     *         * ] (16)
//    5: [ * *   *       *     *         *     *   * * *       *         * ] (16)
//    6: [     *         * * *   *       *     *         *     *   * * *   ] (16)
//    7: [ * *   * * * *   * *   *       *     *         * * *   *       * ] (16)
//    8: [ *       *   * * *         *     *       *   * *   * * * *   * * ] (16)
//    9: [ *       *   * *   * * * *   * *   * * *   *       * * * *   * * ] (16)
//   10: [ *         *       * * *   *     *         *     *       *   * * ] (16)
//   11: [   * * * *   * *   * * *   *     *         *       * * *   *     ] (16)
//   12: [   *     *         *       * * *   *     *       *   * * *       ] (16)
//   13: [   *     *       *   * * *       *   * *   * * * *   * * *       ] (16)
//   14: [ *   * * *         *     *       *   * * *       *   * *   * * * ] (16)
//   15: [   *       * * *   *     *       *   * * *         *     *       ] (16)
//   16: [ *   * * *       *   * *   * * * *   * * *         *     *       ] (15)
//   17: [ *   * * *         *     *         *       * * *   *     *       ] (15)
//   18: [ *   * *   * * *   *       * * * *   * *   * * * *   * * *       ] (15)
//   19: [   *     *         *       * * * *   * *   * * *   *       * * * ] (15)
//   20: [ *         *     *       *   * * *         *       * * *   *     ] (15)
//   21: [ *         *       * * *   *       * * * *   * *   * * *   *     ] (15)
//   22: [   * * *   *     *         *       * * *   *       * * * *   * * ] (15)
//   23: [ *       *   * * *         *       * * *   *     *         *     ] (15)
//   24: [     *         *     *   * * *       *         * * *   *       * ] (15)
//   25: [     *         * * *   *       * * *   * * * *   * *   *       * ] (15)
//   26: [     *   * * *   * *   * * * *       *   * * *       *         * ] (15)
//   27: [ * *   *       * * *   * * * *       *   * * *   * *   * * * *   ] (15)
//   28: [ * * *       *   * * *   * *   * * * *       *         *     *   ] (15)
//   29: [ * * *       *         *     *         * * *   *       *     *   ] (15)
//   30: [       *     *   * * *       *         *     *         * * *   * ] (15)
//   31: [ * * *   * *   * * * *       *         *     *   * * *       *   ] (15)

// ========== HEADER FILE src/walsh/walshseq.h: ==========

void walsh_seq1(Type *f, ulong ldn);
// Sequency-ordered Walsh transform.
// Radix-2 decimation in frequency (DIF) algorithm
//.
// The basis (sequency at end of lines, '*':=1, ' ':=-1):
//  0: [* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *] ( 0)
//  1: [* * * * * * * * * * * * * * * *                                ] ( 1)
//  2: [                * * * * * * * * * * * * * * * *                ] ( 2)
//  3: [* * * * * * * *                 * * * * * * * *                ] ( 3)
//  4: [        * * * * * * * *                 * * * * * * * *        ] ( 4)
//  5: [        * * * * * * * *         * * * *                 * * * *] ( 5)
//  6: [        * * * *         * * * * * * * *         * * * *        ] ( 6)
//  7: [* * * *         * * * *         * * * *         * * * *        ] ( 7)
//  8: [    * * * *         * * * *         * * * *         * * * *    ] ( 8)
//  9: [    * * * *         * * * *     * *         * * * *         * *] ( 9)
// 10: [* *         * *     * * * *         * * * *     * *         * *] (10)
// 11: [    * * * *     * *         * *     * * * *     * *         * *] (11)
// 12: [    * *     * * * *     * *         * *     * * * *     * *    ] (12)
// 13: [    * *     * * * *     * *     * *     * *         * *     * *] (13)
// 14: [    * *     * *     * *     * * * *     * *     * *     * *    ] (14)
// 15: [* *     * *     * *     * *     * *     * *     * *     * *    ] (15)
// 16: [  * *     * *     * *     * *     * *     * *     * *     * *  ] (16)
// 17: [  * *     * *     * *     * *   *     * *     * *     * *     *] (17)
// 18: [*     * *     *   * *     * *     * *     * *   *     * *     *] (18)
// 19: [  * *     * *   *     * *     *   * *     * *   *     * *     *] (19)
// 20: [*     *   * *     * *   *     * *     *   * *     * *   *     *] (20)
// 21: [*     *   * *     * *   *     *   * *   *     * *     *   * *  ] (21)
// 22: [*     *   * *   *     *   * *     * *   *     *   * *   *     *] (22)
// 23: [  * *   *     *   * *   *     *   * *   *     *   * *   *     *] (23)
// 24: [  *   * *   *     *   * *   *     *   * *   *     *   * *   *  ] (24)
// 25: [  *   * *   *     *   * *   *   *   *     *   * *   *     *   *] (25)
// 26: [*   *     *   *   *   * *   *     *   * *   *   *   *     *   *] (26)
// 27: [  *   * *   *   *   *     *   *   *   * *   *   *   *     *   *] (27)
// 28: [  *   *   *   * *   *   *   *     *   *   *   * *   *   *   *  ] (28)
// 29: [  *   *   *   * *   *   *   *   *   *   *   *     *   *   *   *] (29)
// 30: [  *   *   *   *   *   *   *   * *   *   *   *   *   *   *   *  ] (30)
// 31: [*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  ] (31)

void inverse_walsh_seq1(Type *f, ulong ldn);
// Inverse of walsh_seq1().
// radix-2 decimation in time (DIT) algorithm.

void walsh_seq2(Type *f, ulong ldn);
// Sequency-ordered Walsh transform.
//.
// The basis (sequency at end of lines, '*':=1, ' ':=-1):
//  0: [* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *] ( 0)
//  1: [* * * * * * * * * * * * * * * *                                ] ( 1)
//  2: [* * * * * * * *                                 * * * * * * * *] ( 2)
//  3: [                * * * * * * * *                 * * * * * * * *] ( 3)
//  4: [* * * *                 * * * * * * * *                 * * * *] ( 4)
//  5: [* * * *                 * * * *         * * * * * * * *        ] ( 5)
//  6: [        * * * *         * * * * * * * *         * * * *        ] ( 6)
//  7: [* * * *         * * * *         * * * *         * * * *        ] ( 7)
//  8: [* *         * * * *         * * * *         * * * *         * *] ( 8)
//  9: [* *         * * * *         * *     * * * *         * * * *    ] ( 9)
// 10: [* *         * *     * * * *         * * * *     * *         * *] (10)
// 11: [    * * * *     * *         * *     * * * *     * *         * *] (11)
// 12: [    * *     * * * *     * *         * *     * * * *     * *    ] (12)
// 13: [    * *     * * * *     * *     * *     * *         * *     * *] (13)
// 14: [* *     * *     * *     * *         * *     * *     * *     * *] (14)
// 15: [    * *     * *     * *     * *     * *     * *     * *     * *] (15)
// 16: [*     * *     * *     * *     * *     * *     * *     * *     *] (16)
// 17: [*     * *     * *     * *     *   * *     * *     * *     * *  ] (17)
// 18: [*     * *     *   * *     * *     * *     * *   *     * *     *] (18)
// 19: [  * *     * *   *     * *     *   * *     * *   *     * *     *] (19)
// 20: [*     *   * *     * *   *     * *     *   * *     * *   *     *] (20)
// 21: [*     *   * *     * *   *     *   * *   *     * *     *   * *  ] (21)
// 22: [  * *   *     *   * *   *     * *     *   * *   *     *   * *  ] (22)
// 23: [*     *   * *   *     *   * *   *     *   * *   *     *   * *  ] (23)
// 24: [  *   * *   *     *   * *   *     *   * *   *     *   * *   *  ] (24)
// 25: [  *   * *   *     *   * *   *   *   *     *   * *   *     *   *] (25)
// 26: [  *   * *   *   *   *     *   * *   *     *   *   *   * *   *  ] (26)
// 27: [*   *     *   *   *   * *   *   *   *     *   *   *   * *   *  ] (27)
// 28: [*   *   *   *     *   *   *   * *   *   *   *     *   *   *   *] (28)
// 29: [*   *   *   *     *   *   *   *   *   *   *   * *   *   *   *  ] (29)
// 30: [  *   *   *   *   *   *   *   * *   *   *   *   *   *   *   *  ] (30)
// 31: [*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  ] (31)

void inverse_walsh_seq2(Type *f, ulong ldn);
// Inverse walsh_seq2().

// ========== HEADER FILE src/walsh/walshwak.h: ==========

inline void walsh_wak(Type *f, ulong ldn);
// Transform wrt. to Walsh-Kronecker basis (wak-functions).
// Self-inverse.
//.
// The basis: (sequency at end of lines, '*':=+1, ' ':=-1)
//  0: [* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *] ( 0)
//  1: [*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  ] (31)
//  2: [* *     * *     * *     * *     * *     * *     * *     * *    ] (15)
//  3: [*     * *     * *     * *     * *     * *     * *     * *     *] (16)
//  4: [* * * *         * * * *         * * * *         * * * *        ] ( 7)
//  5: [*   *     *   * *   *     *   * *   *     *   * *   *     *   *] (24)
//  6: [* *         * * * *         * * * *         * * * *         * *] ( 8)
//  7: [*     *   * *   *     *   * *   *     *   * *   *     *   * *  ] (23)
//  8: [* * * * * * * *                 * * * * * * * *                ] ( 3)
//  9: [*   *   *   *     *   *   *   * *   *   *   *     *   *   *   *] (28)
// 10: [* *     * *         * *     * * * *     * *         * *     * *] (12)
// 11: [*     * *     *   * *     * *   *     * *     *   * *     * *  ] (19)
// 12: [* * * *                 * * * * * * * *                 * * * *] ( 4)
// 13: [*   *     *   *   *   * *   *   *   *     *   *   *   * *   *  ] (27)
// 14: [* *         * *     * * * *     * *         * *     * * * *    ] (11)
// 15: [*     *   * *     * *   *     * *     *   * *     * *   *     *] (20)
// 16: [* * * * * * * * * * * * * * * *                                ] ( 1)
// 17: [*   *   *   *   *   *   *   *     *   *   *   *   *   *   *   *] (30)
// 18: [* *     * *     * *     * *         * *     * *     * *     * *] (14)
// 19: [*     * *     * *     * *     *   * *     * *     * *     * *  ] (17)
// 20: [* * * *         * * * *                 * * * *         * * * *] ( 6)
// 21: [*   *     *   * *   *     *   *   *   * *   *     *   * *   *  ] (25)
// 22: [* *         * * * *         * *     * * * *         * * * *    ] ( 9)
// 23: [*     *   * *   *     *   * *     * *   *     *   * *   *     *] (22)
// 24: [* * * * * * * *                                 * * * * * * * *] ( 2)
// 25: [*   *   *   *     *   *   *   *   *   *   *   * *   *   *   *  ] (29)
// 26: [* *     * *         * *     * *     * *     * * * *     * *    ] (13)
// 27: [*     * *     *   * *     * *     * *     * *   *     * *     *] (18)
// 28: [* * * *                 * * * *         * * * * * * * *        ] ( 5)
// 29: [*   *     *   *   *   * *   *     *   * *   *   *   *     *   *] (26)
// 30: [* *         * *     * * * *         * * * *     * *         * *] (10)
// 31: [*     *   * *     * *   *     *   * *   *     * *     *   * *  ] (21)

// ========== HEADER FILE src/walsh/walshwak2.h: ==========

void walsh_wak_dif2(Type *f, ulong ldn);
// Transform wrt. to Walsh-Kronecker basis (wak-functions).
// Radix-2 decimation in frequency (DIF) algorithm.
// Self-inverse.

void walsh_wak_dit2(Type *f, ulong ldn);
// Transform wrt. to Walsh-Kronecker basis (wak-functions).
// Radix-2 decimation in time (DIT) algorithm.
// Self-inverse.

// ========== HEADER FILE src/walsh/walshwak4.h: ==========

void walsh_wak_dif4(Type *f, ulong ldn);
// Transform wrt. to Walsh-Kronecker basis (wak-functions).
// Radix-4 decimation in frequency (DIF) algorithm.
// Self-inverse.

void walsh_wak_dit4(Type *f, ulong ldn);
// Transform wrt. to Walsh-Kronecker basis (wak-functions).
// Radix-4 decimation in time (DIT) algorithm.
// Self-inverse.

// ========== HEADER FILE src/walsh/walshwak8.h: ==========

void walsh_wak_dif8(Type *f, ulong ldn);
// Transform wrt. to Walsh-Kronecker basis (wak-functions).
// Radix-8 decimation in frequency (DIF) algorithm.
// Self-inverse.

void walsh_wak_dit8(Type *f, ulong ldn);
// Transform wrt. to Walsh-Kronecker basis (wak-functions).
// Radix-8 decimation in time (DIT) algorithm.
// Self-inverse.

// ========== HEADER FILE src/walsh/walshwakloc2.h: ==========

void walsh_wak_loc_dif2(Type *f, ulong ldn);
// Walsh (wak) transform.
// Recursive decimation in frequency (DIF) algorithm.
// Excellent performance for large array sizes.

void walsh_wak_loc_dit2(Type *f, ulong ldn);
// Walsh (wak) transform.
// Recursive decimation in time (DIT) algorithm.
// Excellent performance for large array sizes.

// ========== HEADER FILE src/walsh/walshwal.h: ==========

void walsh_wal_dif2_core(Type *f, ulong ldn);
// Core routine for sequency-ordered Walsh transform.
// Radix-2 decimation in frequency (DIF) algorithm.
//.
// walsh_wal(f, ldn)
//   =^=
// revbin_permute(f, n);  walsh_wal_dif2_core(f, ldn);
// The routine gray_permute() is absorbed.

void walsh_wal_dit2_core(Type *f, ulong ldn);
// core routine for sequency-ordered Walsh transform.
// Radix-2 decimation in time (DIT) algorithm.
//.
// walsh_wal(f, ldn)
//   =^=
//   walsh_wal_dit2_core(f, ldn);  revbin_permute(f, n);
// The routine gray_permute() is absorbed

inline void walsh_wal(Type *f, ulong ldn);
// Sequency-ordered Walsh transform.
// Transform wrt. to Walsh-Kaczmarz basis (wal-functions)
// The wal functions are sequency-ordered.
//.
// The basis: (sequency at end of lines, '*':=1, ' ':=-1)
//  0: [* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *] ( 0)
//  1: [* * * * * * * * * * * * * * * *                                ] ( 1)
//  2: [* * * * * * * *                                 * * * * * * * *] ( 2)
//  3: [* * * * * * * *                 * * * * * * * *                ] ( 3)
//  4: [* * * *                 * * * * * * * *                 * * * *] ( 4)
//  5: [* * * *                 * * * *         * * * * * * * *        ] ( 5)
//  6: [* * * *         * * * *                 * * * *         * * * *] ( 6)
//  7: [* * * *         * * * *         * * * *         * * * *        ] ( 7)
//  8: [* *         * * * *         * * * *         * * * *         * *] ( 8)
//  9: [* *         * * * *         * *     * * * *         * * * *    ] ( 9)
// 10: [* *         * *     * * * *         * * * *     * *         * *] (10)
// 11: [* *         * *     * * * *     * *         * *     * * * *    ] (11)
// 12: [* *     * *         * *     * * * *     * *         * *     * *] (12)
// 13: [* *     * *         * *     * *     * *     * * * *     * *    ] (13)
// 14: [* *     * *     * *     * *         * *     * *     * *     * *] (14)
// 15: [* *     * *     * *     * *     * *     * *     * *     * *    ] (15)
// 16: [*     * *     * *     * *     * *     * *     * *     * *     *] (16)
// 17: [*     * *     * *     * *     *   * *     * *     * *     * *  ] (17)
// 18: [*     * *     *   * *     * *     * *     * *   *     * *     *] (18)
// 19: [*     * *     *   * *     * *   *     * *     *   * *     * *  ] (19)
// 20: [*     *   * *     * *   *     * *     *   * *     * *   *     *] (20)
// 21: [*     *   * *     * *   *     *   * *   *     * *     *   * *  ] (21)
// 22: [*     *   * *   *     *   * *     * *   *     *   * *   *     *] (22)
// 23: [*     *   * *   *     *   * *   *     *   * *   *     *   * *  ] (23)
// 24: [*   *     *   * *   *     *   * *   *     *   * *   *     *   *] (24)
// 25: [*   *     *   * *   *     *   *   *   * *   *     *   * *   *  ] (25)
// 26: [*   *     *   *   *   * *   *     *   * *   *   *   *     *   *] (26)
// 27: [*   *     *   *   *   * *   *   *   *     *   *   *   * *   *  ] (27)
// 28: [*   *   *   *     *   *   *   * *   *   *   *     *   *   *   *] (28)
// 29: [*   *   *   *     *   *   *   *   *   *   *   * *   *   *   *  ] (29)
// 30: [*   *   *   *   *   *   *   *     *   *   *   *   *   *   *   *] (30)
// 31: [*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  ] (31)

// ========== HEADER FILE src/walsh/walshwalrev.h: ==========

inline void walsh_wal_rev(Type *f, ulong ldn);
// Reversed sequency-ordered walsh transform.
// Self-inverse.
//.
// == void walsh_z1(Type *f, ulong ldn)
// The basis (sequency at end of lines), '*':=1, ' ':=-1:
// 0: [* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *] ( 0)
// 1: [* * * * * * * *                                 * * * * * * * *] ( 2)
// 2: [* * * *                 * * * * * * * *                 * * * *] ( 4)
// 3: [* * * *         * * * *                 * * * *         * * * *] ( 6)
// 4: [* *         * * * *         * * * *         * * * *         * *] ( 8)
// 5: [* *         * *     * * * *         * * * *     * *         * *] (10)
// 6: [* *     * *         * *     * * * *     * *         * *     * *] (12)
// 7: [* *     * *     * *     * *         * *     * *     * *     * *] (14)
// 8: [*     * *     * *     * *     * *     * *     * *     * *     *] (16)
// 9: [*     * *     *   * *     * *     * *     * *   *     * *     *] (18)
//10: [*     *   * *     * *   *     * *     *   * *     * *   *     *] (20)
//11: [*     *   * *   *     *   * *     * *   *     *   * *   *     *] (22)
//12: [*   *     *   * *   *     *   * *   *     *   * *   *     *   *] (24)
//13: [*   *     *   *   *   * *   *     *   * *   *   *   *     *   *] (26)
//14: [*   *   *   *     *   *   *   * *   *   *   *     *   *   *   *] (28)
//15: [*   *   *   *   *   *   *   *     *   *   *   *   *   *   *   *] (30)
//16: [*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *  ] (31)
//17: [*   *   *   *     *   *   *   *   *   *   *   * *   *   *   *  ] (29)
//18: [*   *     *   *   *   * *   *   *   *     *   *   *   * *   *  ] (27)
//19: [*   *     *   * *   *     *   *   *   * *   *     *   * *   *  ] (25)
//20: [*     *   * *   *     *   * *   *     *   * *   *     *   * *  ] (23)
//21: [*     *   * *     * *   *     *   * *   *     * *     *   * *  ] (21)
//22: [*     * *     *   * *     * *   *     * *     *   * *     * *  ] (19)
//23: [*     * *     * *     * *     *   * *     * *     * *     * *  ] (17)
//24: [* *     * *     * *     * *     * *     * *     * *     * *    ] (15)
//25: [* *     * *         * *     * *     * *     * * * *     * *    ] (13)
//26: [* *         * *     * * * *     * *         * *     * * * *    ] (11)
//27: [* *         * * * *         * *     * * * *         * * * *    ] ( 9)
//28: [* * * *         * * * *         * * * *         * * * *        ] ( 7)
//29: [* * * *                 * * * *         * * * * * * * *        ] ( 5)
//30: [* * * * * * * *                 * * * * * * * *                ] ( 3)
//31: [* * * * * * * * * * * * * * * *                                ] ( 1)

// ========== HEADER FILE src/walsh/weighted-arithtransform.h: ==========

void arith_transform_plus(Type *f, ulong ldn, Type w);
// Weighted arithmetic transform (positive sign).

void arith_transform_minus(Type *f, ulong ldn, Type w);
// Weighted arithmetic transform (negative sign).
// Inverse of (weighted) arith_transform_plus().

void rev_arith_transform_plus(Type *f, ulong ldn, Type w);
// Weighted reversed arithmetic transform (positive sign).

void rev_arith_transform_minus(Type *f, ulong ldn, Type w);
// Weighted reversed arithmetic transform (negative sign).
// Inverse of (weighted) rev_arith_transform_plus().

// ========== HEADER FILE src/walsh/weighted-or-convolution.h: ==========

inline void slow_weighted_or_convolution(const Type *f, const Type *g, ulong ldn, Type *h, Type w);
// Compute the weighted OR-convolution h[] of f[] and g[]:
//  h[k] = sum(i | j == k,  f[i]*g[j] * (w)**bitcount(i&j))
// Result written to h[].

inline void slow_weighted_or_convolution(const Type *f, Type *g, ulong ldn, Type w);
// Result written to g[].

inline void weighted_or_convolution(Type * restrict f, Type * restrict g, ulong ldn, Type w);
// Compute the weighted OR-convolution h[] of f[] and g[]:
//  h[k] = sum(i | j == k,  f[i]*g[j] * (w)**bitcount(i&j))
// f[] and g[] must not overlap.
// Result written to g[].

inline void weighted_or_auto_convolution(Type * restrict f, ulong ldn, Type w);
// Compute the weighted self- OR-convolution h[] of f[]:
//  h[k] = sum(i | j == k,  f[i]*f[j] * (w)**bitcount(i&j))
// Result written to f[].

